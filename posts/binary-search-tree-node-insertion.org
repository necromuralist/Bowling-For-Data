#+BEGIN_COMMENT
.. title: Binary Search Tree Node Insertion
.. slug: binary-search-tree-node-insertion
.. date: 2022-03-12 15:23:47 UTC-08:00
.. tags: data structures,binary search trees,algorithms
.. category: Data Structures
.. link: 
.. description: Implementing a Binary Search Tree and Node Insertion.
.. type: text
.. has_pseudocode: yas
#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-46ad764e-4574-4f8b-9fed-b9c893ab236b-ssh.json
#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
#+begin_src python :tangle ../bowling/data_structures/binary_search_tree/tree.py :exports none
<<imports>>


<<the-tree>>

    <<insert>>
#+end_src
This is the next post in a series on Binary Search Trees that start with {{% lancelot "this post" %}}binary-search-trees{{% /lancelot %}}. In this post we'll be looking at creating a Tree class and the method of inserting a node into the tree.

* The Tree
Although {{% lancelot "CLRS" %}}clrs{{% /lancelot %}} use a *T* (as in tree) class in their algorithms, they only use it to store a *root* attribute. To make it a little more object-oriented I'll create a Tree class and add the ~insert~ method to it, rather than passing the tree to a function. Not a big change, but one that might be useful.

#+begin_src plantuml :file ../files/posts/binary-search-tree-node-insertion/tree.png :exports none
!theme materia-outline

class Tree {
 Node root
 insert(Node node)
}
#+end_src

[[img-url:tree.png]]

#+begin_src python :noweb-ref imports
# pypi
from attrs import define

# this project
from .node import Node
#+end_src

#+begin_src python :noweb-ref the-tree
@define
class Tree:
    """Binary Search Tree

    Args:
     root: the root node for the tree
    """
    root: Node = None
#+end_src

#+begin_src python :results none :exports none
# pypi
from expects import be_none, equal, expect

#software under test
from bowling.data_structures.binary_search_tree import Node
from bowling.data_structures.binary_search_tree.tree import Tree

root = Node(5)
tree = Tree(root=root)

expect(tree.root).to(equal(root))
tree = Tree()
expect(tree.root).to(be_none)
tree.root = root
expect(tree.root).to(equal(root))
#+end_src

** The Insertion Algorithm
This is the {{% lancelot "CLRS" %}}clrs{{% /lancelot %}} insert algorithm. As I noted above they consider it a function, rather than a method of the tree.

One thing that tripped me up initially was the term "insert". I thought that it would put the new node in between existing nodes, but it instead adds it as a leaf. The job of the algorithm is to find the correct leaf to add the new node to and which side to put it on (left or right).

#+begin_export html
<pre id="insert-node" style="display:hidden;">
\begin{algorithm}
\caption{Insert Node}
\begin{algorithmic}

\INPUT Tree and Node to insert.
\PROCEDURE{TreeInsert}{\textit{T, z}}

\STATE \textit{y} $\gets$ \textsc{NIL}
\STATE \textit{x} $\gets$ T.root

\WHILE {\textit{x} $\neq$ \textsc{NIL}}
 \STATE \textit{y} = \textit{x}
 \IF {\textit{z}.key < \textit{x}.key}
   \STATE \textit{x} $\gets$ \textit{x}.left
 \ELSE
   \STATE \textit{x} $\gets$ \textit{x}.right
 \ENDIF
\ENDWHILE
\STATE
\STATE \textit{z}.parent $\gets$ \textit{y}
\STATE
\IF {\textit{y} = \textsc{NIL}} 
 \STATE T.root $\gets$ \textit{z}
\ELIF {\textit{z}.key < \textit{y}.key}
  \STATE \textit{y}.left $\gets$ \textit{z}
\ELSE
  \STATE \textit{y}.right $\gets$ \textit{z}
\ENDIF

\ENDPROCEDURE

\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

What we have here is sort of a hunter and hound scenario. The hunter ~y~ is pulled along by the hound ~x~ as the hound chases down the path to find the spot for the new node. Once the hound falls into the spot where there's no node, the hunter is in the location of the leaf that should be the new node's parent and the hound is where the new node should be inserted.

** The Insert Method
#+begin_src python :noweb-ref insert
def insert(self, node: Node) -> None:
    """Insert the node as a new leaf in the tree

    Args:
     node: a node to insert into the tree
    """
    hunter, hound = None, self.root

    while hound is not None:
        hunter, hound = hound, hound.left if node < hound else hound.right

    node.parent = hunter

    if hunter is None:
        self.root = node
    elif node.key < hunter.key:
        hunter.left = node
    else:
        hunter.right = node
    return
#+end_src

#+begin_src python :results none
from bowling.data_structures.binary_search_tree.tree import Tree
tree = Tree()

tree.insert(Node(12))
expect(tree.root).to(equal(Node(12)))

tree.insert(Node(7))
expect(tree.root.left).to(equal(Node(7)))

tree.insert(Node(20))
expect(tree.root.right).to(equal(Node(20)))

tree.insert(Node(10))
expect(tree.root.left.right).to(equal(Node(10)))
#+end_src

* Plotting
#+begin_src python :results output :exports both
tree = Tree(Node(10))
for key in (5, 2, 3, 1, 7, 6, 8, 15, 12, 11, 14, 17, 16, 20):
    tree.insert(Node(key))
adjacencies = dict()

def inorder(node: Node, adjacencies: dict) -> dict:
    """Traverse the nodes and build an adjancency dictionary
    """
    if node is not None:
        inorder(node.left, adjacencies)
        left = node.left.key if node.left else None
        right = node.right.key if node.right else None
        if any((left, right)):
            if left and right:
                adjacencies[node.key] = (left, right)
            elif left and not right:
                adjacencies[node.key] = (left, )
            else:
                adjacencies[node.key] = (right,)
            inorder(node.right, adjacencies)
    return

inorder(tree.root, adjacencies=adjacencies)
print(adjacencies)
#+end_src

#+RESULTS:
: {2: (1, 3), 5: (2, 7), 7: (6, 8), 10: (5, 15), 12: (11, 14), 15: (12, 17), 17: (16, 20)}

Now that we have an adjacency list, let's try and plot it.
#+begin_src python :results none
import networkx

SLUG = "binary-search-tree-node-insertion"
OUTPUT = f"files/posts/{SLUG}/"

graph = networkx.DiGraph(adjacencies)

pygraph = networkx.nx_pydot.to_pydot(graph)
pygraph.write_png(OUTPUT + "first_tree.png")
#+end_src

[[img-url: first_tree.png]]

This is sort of an artificial example in that in order to get the plot right I had to insert nodes until they all had two (except the leaves), but it hopefully shows that it works.
* Sources
- {{% doc %}}clrs{{% /doc %}}

#+begin_export html
<script>
window.addEventListener('load', function () {
    pseudocode.renderElement(document.getElementById("insert-node"));
});
</script>
#+end_export

