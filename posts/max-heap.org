#+BEGIN_COMMENT
.. title: Heap!
.. slug: max-heap
.. date: 2022-02-08 13:40:58 UTC-08:00
.. tags: data structures,heap,algorithms
.. category: Algorithms
.. link: 
.. description: A max-heap.
.. type: text
.. has_pseudocode: yes!
#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-f7ebe7fa-5518-40ec-b1d6-482dbc0e580d-ssh.json

#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
* Beginning
** What's a Heap?
This is a post that looks at [[https://en.wikipedia.org/wiki/Heap_(data_structure)][Heaps]]. According to {{% doc %}}clrs{{% /doc %}}, a heap is an array that can be thought of as a nearly complete binary tree which satisfies the **Heap Property**. There are actually two heap properties, one for a **Max Heap** and one for a **Min Heap**.

- **Max-Heap Property**: \(A[Parent(i)]) \ge A[i]\)
- **Min-Heap Property**: \(A[Parent(i)]) \le A[i]\)

The heap has (at least) two attributes.

- /A.length/: the number of elements in the array
- /A.heap-size/: the number of elements in the heap (not all elements in the array need to be in the heap)

The first element in the heap is the root (for the Max-Heap it is the largest element, for the Min-Heap it is the smallest).

** Some Functions
For any Node in the Heap located at /i/:

#+begin_export html
<pre id="parent" style="display:hidden;">
\begin{algorithm}
\caption{Parent}
\begin{algorithmic}
\INPUT The index of a Child Node
\OUTPUT The index of the Child's Parent
\PROCEDURE{Parent}{$i$}
 \RETURN {\(\left \lfloor \frac{i}{2} \right \rfloor\)}
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

#+begin_export html
<pre id="left" style="display:hidden;">
\begin{algorithm}
\caption{Left}
\begin{algorithmic}
\INPUT The index of a Parent Node
\OUTPUT The index of the Parent's left child node
\PROCEDURE{Left}{$i$}
 \RETURN 2i
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

#+begin_export html
<pre id="right" style="display:hidden;">
\begin{algorithm}
\caption{Right}
\begin{algorithmic}
\INPUT The index of a Parent Node
\OUTPUT The index of the Parent's right child node
\PROCEDURE{Right}{$i$}
 \RETURN 2i + 1
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

There are also two requirements:

 - **Shape Requirement**: All levels but the last have to be complete (only the rightmost leaves can be incomplete)
 - **Dominance Requirement**: Every node is greater than or equal to its children (in the Max-Heap, less than or equal for the Min-Heap)

* The Max Heap
** The Imports
#+begin_src python :results none
# python
from collections.abc import MutableSequence
from functools import partial
from typing import Generator

import random

# pypi
from attrs import define
from expects import contain_exactly, equal, expect, raise_error

from graeae import EmbedHoloviews
#+end_src

#+begin_src python :results none
SLUG = "max-heap"
path = f"files/posts/{SLUG}/"
Embed = partial(EmbedHoloviews, folder_path=path)
#+end_src
** The Class
#+begin_src python :results none
@define
class MaxHeap:
    """Build and maintain a max-heap

    If you pass in the heap as a list pre-pend it with Infinity

    Otherwise use ~heap = MaxHeap.from_list(elements)~ to build it
    """
    INFINITY = float("inf")
    NEGATIVE_INFINITY = -INFINITY
    ROOT_NODE = 1

    heap: list = [INFINITY]
    _size: int = None

    @classmethod
    def from_list(cls, heap: list) -> MaxHeap:
        """Builds a max-heap instance from the starter list"""
        return cls(heap = [cls.INFINITY] + heap)

    @property
    def size(self) -> int:
        """The size of the max heap"""
        if self._size is None:
            self._size = len(self.heap) - 1
        return self._size

    @size.setter
    def size(self, new_size) -> int:
        """Set the size of the max heap

        Args:
         new_size: how much of the list is in the heap
        """
        assert 0 < new_size <= self.length
        self._size = new_size
        return

    @property
    def length(self) -> int:
        """The size of the array for the heap"""
        return len(self.heap)

    @property
    def maximum(self):
        """The value in the root node"""
        return self.heap[self.ROOT_NODE]

    def parent(self, node: int) -> int:
        """Find the parent of a node

        Args:
         node: the index of the node to check

        Returns:
         the index of the parent of the node
        """
        return node//2

    def left(self, parent: int) -> int:
        """Find the left child of a parent

        Args:
         parent: the index of the parent node

        Returns:
         index of the left child of the parent
        """
        return 2 * parent

    def right(self, parent: int) -> int:
        """Find the right child of a parent

        Args:
         parent: the index of the parent node

        Returns:
         index of the right child of the parent
        """
        return 2 * parent + 1

    def heapify_subtree(self, node):
        """Heapify the tree rooted at the node

        Args:
         node: index of the current root of the tree        
        """
        left, right = self.left(node), self.right(node)
        if left <= self.size and self.heap[left] > self.heap[node]:
            largest = left

        else:
            largest = node

        if right <= self.size and self.heap[right] > self.heap[largest]:
            largest = right

        if largest != node:
            self.heap[node], self.heap[largest] = (self.heap[largest],
                                                   self.heap[node])
            self.heapify_subtree(largest)
        return

    def increase_key(self, node, key):
        """Increase the node's value

        Args:
         node: index of node in heap to change
         key: new value for the node
        """
        assert key > self.heap[node]
        self.heap[node] = key

        while node > 1 and self.heap[self.parent(node)] < self.heap[node]:
            self.heap[node], self.heap[self.parent(node)] = (
                self.heap[self.parent(node)], self.heap[node])
            node = self.parent(node)
        return

    def insert(self, key):
        """Insert the key into the heap

        Args:
         key: orderable item to insert into the heap
        """
        self.size += 1
        self.heap[self.size - 1] = self.NEGATIVE_INFINITY
        self.increase_key(self.size - 1, key)
        return
        
    def __getitem__(self, key: int):
        """Gets an item from the heap
        
        Args: 
         key: index of the heap to get the value
        """
        return self.heap[key]

    def __setitem__(self, key, value):
        """Sets the value at the key in the heap

        Args:
         key: index of the heap to set the value
         value: what to set the location in the heap to
        """
        self.heap[key] = value
        return
    
    def __call__(self):
        """Heapifies the heap
        """
        for parent in reversed(range(1, self.size//2 + 1)):
            self.heapify_subtree(parent)

        self.check_rep()
        return

    def check_rep(self) -> None:
        """Checks the heap property
        
        Raises:
         AssertionError: the heap property has been violated
        """
        for node in range(1, self.size):
            assert self.heap[self.parent(node)] >= self.heap[node], (
                f"Parent node {self.parent(node)} = {self.heap[self.parent(node)]} "
                f"not >= {node}={self.heap[node]}")
        return
#+end_src
** The Tests

#+begin_src python :results none
start = [10, 20, 5]
max_heap = MaxHeap.from_list(heap=start)

expect(max_heap.heap).to(equal([max_heap.INFINITY] + start))
expect(max_heap.size).to(equal(3))
expect(max_heap.length).to(equal(4))

expect(max_heap.parent(1)).to(equal(0))
expect(max_heap.parent(2)).to(equal(1))
expect(max_heap.parent(3)).to(equal(1))

expect(max_heap.left(1)).to(equal(2))
expect(max_heap.right(1)).to(equal(3))

def failure(): max_heap.check_rep()

expect(failure).to(raise_error(AssertionError))

expect(max_heap.maximum).to(equal(10))
#+end_src

#+begin_src python :results none
start = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1]
heap = MaxHeap.from_list(start)
expect(heap.maximum).to(equal(16))

heap.heapify_subtree(2)
expect(heap[2]).to(equal(14))

heap.heapify_subtree(1)
expect(heap.maximum).to(equal(16))
expect(heap[2]).to(equal(14))
expect(heap[4]).to(equal(8))
expect(heap[9]).to(equal(4))
#+end_src

#+begin_src python :results none
start = [10, 20, 30, 40]
heap = MaxHeap.from_list(start)
heap()
expect(heap.maximum).to(equal(40))
#+end_src

#+begin_src python :results none
start = [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]
heap = MaxHeap.from_list(start)
expect(heap.maximum).to(equal(1))

heap()
expect(heap.maximum).to(equal(16))
#+end_src
* Heap Sort
#+begin_src python :results none
@define
class HeapSort:
    """Sort using a heap

    Args:
     items: collection of items for the sort
    """
    items: list
    _heap: MaxHeap=None

    @property
    def heap(self) -> MaxHeap:
        """The heap of items"""
        if self._heap is None:
            self._heap = MaxHeap.from_list(self.items)
            self._heap()
        return self._heap

    @property
    def without_root(self) -> list:
        """The items without the root """
        return self.heap.heap[self.heap.ROOT_NODE:]

    def __call__(self):
        """sorts the items"""
        self.heap()
        for node in range(self.heap.size, 1, -1):
            self.heap.heap[self.heap.ROOT_NODE], self.heap.heap[node] = (
                self.heap.heap[node],
                self.heap.maximum)
            self.heap.size -= 1
            self.heap()
        return
#+end_src

** The Tests
#+begin_src python :results none
k = 100
items = random.choices(range(k), k=k)
sorter = HeapSort(items)

sorter()

items.sort()
expect(sorter.without_root).to(contain_exactly(*items))
#+end_src
* A Priority Queue
Although some books mention that MinHeaps are used for priority queues, CLRS shows a MaxHeap version. This involves adding a couple of methods to the MaxHeap so there's no special class.

** The Tests

#+begin_src python :results none
items = [1, 2, 3]
heap = MaxHeap.from_list(items)
heap()

def failure(): heap.increase_key(2, 0)
expect(failure).to(raise_error(AssertionError))

heap.increase_key(2, 5)
expect(heap.maximum).to(equal(5))

items = [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]
heap = MaxHeap.from_list(items)
heap()
heap.increase_key(9, 15)
expect(heap[heap.left(1)]).to(equal(15))

heap.insert(20)
expect(heap.size).to(equal(len(items) + 1))
expect(heap.maximum).to(equal(20))
#+end_src
* Plotting
#+begin_src python :results none
from networkx import Graph
import holoviews

graph = Graph()
for node in range(1, len(heap.heap)//2+ 1):
    if heap.left(node) < heap.length:
        graph.add_edge(heap.heap[node], heap.heap[heap.left(node)])
    if heap.right(node) < heap.length:
        graph.add_edge(heap.heap[node], heap.heap[heap.right(node)])
positions = networkx.drawing.nx_pydot.graphviz_layout(graph, prog="dot")

plot = holoviews.Graph.from_networkx(graph, positions)

output = Embed(plot=plot, file_name="heap-plot")()
#+end_src

#+begin_src python :results output html :exports results
print(output)
#+end_src

#+RESULTS:
#+begin_export html
<object type="text/html" data="heap-plot.html" style="width:100%" height=800>
  <p>Figure Missing</p>
</object>
#+end_export

* End
#+begin_export html
<script>
window.addEventListener('load', function () {
    pseudocode.renderElement(document.getElementById("parent"));
});
</script>
#+end_export

#+begin_export html
<script>
window.addEventListener('load', function () {
    pseudocode.renderElement(document.getElementById("left"));
});
</script>
#+end_export

#+begin_export html
<script>
window.addEventListener('load', function () {
    pseudocode.renderElement(document.getElementById("right"));
});
</script>
#+end_export
