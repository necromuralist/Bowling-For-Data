#+BEGIN_COMMENT
.. title: NYC Shootings Python Version
.. slug: nyc-shootings-python-version
.. date: 2023-03-22 13:18:14 UTC-07:00
.. tags: pandas,data science,data exploration
.. category: Data Exploration
.. link: 
.. description: The NYPD Shooting Incident Data (Python Version)
.. type: text

#+END_COMMENT

#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-2b33afec-4db8-4912-933c-8fb207910a94-ssh.json
#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC

* NYPD Shooting Incident Data Version 2 (with python)

This is a replication (more or less) of the {{% doc %}}nypd-shooting-incident-data{{%  /doc %}} post which we did using R but this time we'll use python and pandas instead. Once again we'll be looking at the [[https://catalog.data.gov/dataset/nypd-shooting-incident-data-historic][NYPD Shooting Incident Data (Historic)]] from the [[https://catalog.data.gov/dataset][DATA.gov]] catalog of datasets, which lists every shooting from 2006 through the last updated incident (as of March 22, 2023 it shows that it was last updated June 9, 2022 but we'll have to look at it to see what the date of the last incident was).

** Imports and Setup

#+begin_src python :results none
# python
from functools import partial
import sys

# pypi
from expects import equal, expect
from tabulate import tabulate

import altair
import pandas

from graeae.visualization.altair_helpers import output_path, save_chart
#+end_src

First, let's double-check which version of python we're using.

#+begin_src python :results output :exports both
print(sys.version)
#+end_src

#+RESULTS:
: 3.9.9 (main, Dec  3 2021, 01:15:49) 
: [GCC 10.2.1 20210110]

We're running python 3.9.9. I was running it in pypy but for some reason the pandas' ~groupby~ method would hang so this is done in cPython.

This next bit is a little setup to make nicer tables.

#+begin_src python :results none
TABLE = partial(tabulate, headers="keys", showindex=False, tablefmt="orgtbl")
#+end_src

This is to help with the plotting.

#+begin_src python :results none
SLUG = "nyc-shootings-python-version"
OUTPUT_PATH = output_path(SLUG)
save_it = partial(save_chart, output_path=OUTPUT_PATH, height=650)
#+end_src

* The Data
** Loading It

The data is available to download as a CSV so we'll pass the URL for the CSV to pandas and make a dataframe.

#+begin_src python :results none
URL = "https://data.cityofnewyork.us/api/views/833y-fsy8/rows.csv?accessType=DOWNLOAD"
data = pandas.read_csv(URL)
#+end_src

#+begin_src python :results output :exports both
rows, columns = data.shape
print(f"Rows: {rows:,}\tColumns: {columns}")
#+end_src

#+RESULTS:
: Rows: 25,596	Columns: 19

** The Columns

We'll start looking at the data by examining what's in the columns. We saw from the data frame's shape that we have 19 columns, how many of them does pandas think are numeric?

#+begin_src python :results output :exports both
print(TABLE(data.describe(), showindex=True))
#+end_src

#+RESULTS:
|       |    INCIDENT_KEY |   PRECINCT |   JURISDICTION_CODE |       X_COORD_CD |   Y_COORD_CD |     Latitude |     Longitude |
|-------+-----------------+------------+---------------------+------------------+--------------+--------------+---------------|
| count | 25596           | 25596      |        25594        |  25596           |      25596   | 25596        | 25596         |
| mean  |     1.12383e+08 |    65.8694 |            0.331601 |      1.00945e+06 |     207894   |    40.7372   |   -73.909     |
| std   |     6.78612e+07 |    27.2019 |            0.742266 |  18421.4         |      31857.4 |     0.087447 |     0.0664265 |
| min   |     9.95324e+06 |     1      |            0        | 914928           |     125757   |    40.5116   |   -74.2493    |
| 25%   |     6.15936e+07 |    44      |            0        |      1.00001e+06 |     182782   |    40.6683   |   -73.9431    |
| 50%   |     8.64373e+07 |    69      |            0        |      1.00772e+06 |     194038   |    40.6991   |   -73.9153    |
| 75%   |     1.66661e+08 |    81      |            0        |      1.01684e+06 |     239429   |    40.8238   |   -73.8824    |
| max   |     2.3849e+08  |   123      |            2        |      1.06682e+06 |     271128   |    40.9108   |   -73.702     |

Just seven of them, and four are coordinates and the other three are categorical. This isn't really surprising, since the data isn't measuring anything but is rather a listing of shooting incidents reported (each row represents a single incident).

There's a table on the [[https://data.cityofnewyork.us/Public-Safety/NYPD-Shooting-Incident-Data-Historic-/833y-fsy8][NYPD-Shooting-Incident-Data]] page that describes the columns.

| Column Name             | Description                                                      | Type        |
|-------------------------+------------------------------------------------------------------+-------------|
| INCIDENT_KEY            | Randomly generated persistent ID for each arrest                 | Plain Text  |
| OCCUR_DATE              | Exact date of the shooting incident                              | Date & Time |
| OCCUR_TIME              | Exact time of the shooting incident                              | Plain Text  |
| BORO                    | Borough where the shooting incident occurred                     | Plain Text  |
| PRECINCT                | Precinct where the shooting incident occurred                    | Plain Text  |
| JURISDICTIONAL_CODE     | Jurisdiction where it occurred                                   | Number      |
| LOCATION_DESC           | Location of the incident                                         | Plain Text  |
| STATISTICAL_MURDER_FLAG | Victim died                                                      | Checkbox    |
| PERP_AGE_GROUP          | Perpetrator's age within a category                              | Plain Text  |
| PERP_SEX                | Pepetrator's sex.                                                | Plain Text  |
| PERP_RACE               | Perpetrator's race.                                              | Plain Text  |
| VIC_AGE_GROUP           | Victim's age with a category.                                    | Plain Text  |
| VIC_SEX                 | Victim's sex.                                                    | Plain Text  |
| VIC_RACE                | Victim's Race                                                    | Plain Text  |
| X_COORD_CD              | Midblock X-coordinate for New York State Plane Coordinate System | Plain Text  |
| Y_COORD_CD              | Midblock Y-coordinate                                            | Plain Text  |
| Latitude                | Latitude coordinate                                              | Number      |
| Longitude               | Longitude                                                        | Number      |
| Lon_Lat                 | Longitude and Latitude Coordinate for mapping                    | Point       |

*** Incident Key

The incident key is an identifier for a specific incident so it's only really useful if you need to look up or refer to one or more of them, but we'll be looking at things in aggregate making them less useful for us, except maybe for looking at anomalies. Let's just make sure that the identifiers are unique as I'm asserting that they are.

#+begin_src python :results output :exports both
id_count = len(data.INCIDENT_KEY.unique())
incidents = len(data)
print(f"Identifiers: {id_count:,}\tIncidents: {incidents:,}")
print(f"There are {incidents - id_count:,} more rows than incident IDs.")
#+end_src

#+RESULTS:
: Identifiers: 20,126	Incidents: 25,596
: There are 5,470 more rows than incident IDs.

It appears that I wasn't correct in my assumption... let's take a look at one of the incidents.

#+begin_src python :results output :exports both
counts = data.INCIDENT_KEY.value_counts()
up_counts = counts[counts > 1]
top = counts.head(1)
top_id = top.index[0]
print(f"Incident: {top_id}\tCount: {top.iloc[0]}")
#+end_src

#+RESULTS:
: Incident: 173354054	Count: 18

Inspecting the dataframe it looks like in some cases more than one person was shot per incident, so there's multiple rows (one per person shot) for a single incident. Kind of scary that eighteen people got shot at one incident, if my interpretation is correct, but that's life in the big city, I guess.

So the Incident Key might be useful to see the cases where multiple people shoot or are shot.

#+begin_src python :results output :exports both
# altair sorts the bar-chart using the x-axis values. There's supposed to be a way
# to turn it off but I couldn't get it to work, thus the second reset_index
# call is to get a column to keep it in order
use_counts = up_counts.reset_index().rename(
    columns={"index": "Incident Key",
             "INCIDENT_KEY": "Shots"}).reset_index()
chart = altair.Chart(use_counts).mark_bar().encode(
    x = "index",
    y="Shots",
    tooltip=[altair.Tooltip("Incident Key"), altair.Tooltip("Shots")]
    
).properties(
   title="Incidents with Multiple Shots",
   width=800,
   height=525
)

save_it(chart, "multiple_shot_incidents")
#+end_src

#+RESULTS:
#+begin_export html
<object type="text/html" data="multiple_shot_incidents.html" style="width:100%" height=600>
  <p>Figure Missing</p>
</object>
#+end_export

It looks like a lot of entries have more than one row. Does this mean many incidents have more than one victim? More than one shooter?

#+begin_src python :results output :exports both
fractions = 100 * counts.value_counts()/len(data)
fractions = fractions.reset_index().rename(columns={
    "index": "Entries", "INCIDENT_KEY": "Percent of Rows"})

chart = altair.Chart(fractions).mark_bar().encode(
    x=altair.X("Entries", sort=fractions["Percent of Rows"].values),
    y=altair.Y("Percent of Rows", scale=altair.Scale(domain=(-1, 70))),
    tooltip=[altair.Tooltip("Entries"),
             altair.Tooltip("Percent of Rows")]).properties(
                 title="Percent Of Incidents with Multiple Rows",
                 width=800,
                 height=525)

save_it(chart, "fraction_row_incidents")
#+end_src

#+RESULTS:
#+begin_export html
<object type="text/html" data="fraction_row_incidents.html" style="width:100%" height=650>
  <p>Figure Missing</p>
</object>
#+end_export

The majority of the incidents do have only one row in the dataset. Perhaps it's not as unusual as I think it is to have multiple people involved in a shooting.

*** OCCUR_DATE and OCCUR_TIME

There are two columns that tell us when the shooting is supposed to have happened.

#+begin_src python :results output :exports both
example = data[data.INCIDENT_KEY==top_id].iloc[0]
print(f"OCCUR_DATE: {example.OCCUR_DATE} ({data.OCCUR_DATE.dtype})")
print(f"OCCUR_TIME: {example.OCCUR_TIME} ({data.OCCUR_TIME.dtype})")
#+end_src

#+RESULTS:
: OCCUR_DATE: 01/06/2018 (object)
: OCCUR_TIME: 21:05:00 (object)

Pandas interpreted both of these as strings, but it'd probably be more useful for us if they were datetime objects.

#+begin_src python :results none
MONTH, DAY, YEAR = "%m", "%d", "%Y"
HOUR, MINUTE, SECOND = "%H", "%M", "%S"
DATE_FORMAT = "/".join((MONTH, DAY, YEAR))
TIME_FORMAT = ":".join((HOUR, MINUTE, SECOND))
FORMAT = f"{DATE_FORMAT} {TIME_FORMAT}"
DATE_COLUMN = "date_time"
data[DATE_COLUMN] = pandas.to_datetime(data.OCCUR_DATE + " " + data.OCCUR_TIME, format=FORMAT)
#+end_src

#+begin_src python :results output :exports both
check_date = data[data.INCIDENT_KEY==top_id].iloc[0]
print(f"OCCUR_DATE: {check_date.OCCUR_DATE}")
print(f"New Date: {check_date.date_time.date()}")
print(f"OCCUR_TIME: {check_date.OCCUR_TIME}")
print(f"New Time: {check_date.date_time.time()}")
#+end_src

#+RESULTS:
: OCCUR_DATE: 01/06/2018
: New Date: 2018-01-06
: OCCUR_TIME: 21:05:00
: New Time: 21:05:00

#+begin_src python :results output :exports both
print(data.OCCUR_DATE.min())
print(data.OCCUR_DATE.max())
#+end_src

#+RESULTS:
: 01/01/2006
: 12/31/2021

Our dataset covers the years from 2006 throught 20021. Let's see how many there are from month to month.

**** Shootings By Month

#+begin_src python :results none
indexed = data.set_index(DATE_COLUMN)
#+end_src

#+begin_src python :results output :exports both
monthly = indexed.groupby(pandas.Grouper(freq="M"))
monthly_counts = monthly.count()["INCIDENT_KEY"].reset_index().rename(
    columns={"INCIDENT_KEY": "Shootings",
             "date_time": "Month"}
)
expect(monthly_counts["Shootings"].sum()).to(equal(len(data)))

chart = altair.Chart(monthly_counts).mark_line(
    point={"filled": False,
           "fill": "white"}).encode(
    x=altair.X("Month"),
    y=altair.Y("Shootings"),
    tooltip=[altair.Tooltip("Month"),
             altair.Tooltip("Shootings")]
).properties(
    width=800,
    height=525,
    title="NYC Shootings By Month"
)

save_it(chart, "monthly_incidents")
#+end_src

#+RESULTS:
#+begin_export html
<object type="text/html" data="monthly_incidents.html" style="width:100%" height=650>
  <p>Figure Missing</p>
</object>
#+end_export

It looks like shootings went down in 2013 then shot back up again in the Summer of 2020.

**** 90 Da Rolling Window

#+begin_src python :results output :exports both
monthly_counts["Rolling Mean"] = monthly_counts["Shootings"].ewm(
    halflife="90 days", times=monthly_counts.Month).mean()
pre_melt = monthly_counts.rename(columns={"Shootings": "Sum"})
melted = pre_melt.melt("Month", var_name="Aggregation", value_name="Aggregated Value")
chart = altair.Chart(melted).mark_line(
    point={"filled": False,
           "fill": "white"}).encode(
               x=altair.X("Month"),
               y=altair.Y("Aggregated Value"),
               color="Aggregation",
               tooltip=[altair.Tooltip("Month"),
                        altair.Tooltip("Aggregated Value"),
                        altair.Tooltip("Aggregation")]
).properties(
    width=800,
    height=525,
    title="NYC Shootings By 90 Day Exponential Weighted Mean"
)

save_it(chart, "monthly_rolling_incidents")
#+end_src

#+RESULTS:
#+begin_export html
<object type="text/html" data="monthly_rolling_incidents.html" style="width:100%" height=650>
  <p>Figure Missing</p>
</object>
#+end_export

Using a ninety-day window gives a little better sense of the overall trend downwards until 2020 reversed it.

**** By Year

#+begin_src python :results output :exports both
yearly = indexed.groupby(pandas.Grouper(freq="Y"))
yearly_counts = yearly.count()["INCIDENT_KEY"].reset_index().rename(
    columns={"INCIDENT_KEY": "Shootings",
             "date_time": "Year"}
)
expect(yearly_counts["Shootings"].sum()).to(equal(len(data)))

chart = altair.Chart(yearly_counts).mark_line(
    point={"filled": False,
           "fill": "white"}).encode(
    x=altair.X("Year"),
    y=altair.Y("Shootings"),
    tooltip=[altair.Tooltip("Year"),
             altair.Tooltip("Shootings")]
).properties(
    width=800,
    height=525,
    title="NYC Shootings By year"
)

save_it(chart, "yearly_incidents")
#+end_src

#+RESULTS:
#+begin_export html
<object type="text/html" data="yearly_incidents.html" style="width:100%" height=650>
  <p>Figure Missing</p>
</object>
#+end_export

Although 2020 had that crazy summer, 2021 still exceeded it overall.

**** Monthly By Year

#+begin_src python :results none
monthly_counts = monthly_counts.rename(columns={"Month": "date-time"})
#+end_src

#+begin_src python :results none
month_map = dict(zip(range(1, 13), "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split()))
monthly_counts["Year"] = monthly_counts["date-time"].apply(lambda date: date.year)
monthly_counts["Month"] = monthly_counts["date-time"].apply(lambda date: month_map[date.month])
#+end_src

#+begin_src python :results output :exports both
chart = altair.Chart(monthly_counts).mark_line(
    point={"filled": False,
           "fill": "white"}).encode(
    x=altair.X("Month",
               sort=monthly_counts["date-time"].values),
    y=altair.Y("Shootings"),
    color=altair.Color("Year", type="nominal"),
    tooltip=[altair.Tooltip("Year"),
             altair.Tooltip("Month"),
             altair.Tooltip("Shootings")]
).properties(
    width=800,
    height=525,
    title="NYC Monthly Shootings By year"
)

save_it(chart, "month_year_shootings")
#+end_src

#+RESULTS:
#+begin_export html
<object type="text/html" data="month_year_shootings.html" style="width:100%" height=650>
  <p>Figure Missing</p>
</object>
#+end_export
