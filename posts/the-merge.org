#+BEGIN_COMMENT
.. title: The Merge
.. slug: the-merge
.. date: 2022-01-23 17:32:22 UTC-08:00
.. tags: sorting,algorithms
.. category: Sorting
.. link:
.. description: The Merge algorithm.
.. type: text
.. has_pseudocode: yes indeed
#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-05f299e0-f06a-41df-80b9-56964580830e-ssh.json
#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
* The Merge
This is an implementation of the merge portion of the merge-sort. It takes two sorted sections of a collection and merges them together in place.

** The Algorithm
The precondition for this to work is that there are two sections within the array passed in to the algorithm that are already sorted and that they are located by the three index-values given to the algorithm. The first sorted section starts at ~p~ and ends at ~q~ in the array and the second sorted section starts at ~q + 1~ and ends at ~r~ within the array.

This is the CLRS version with the indexing changed to start at 0.

#+begin_export html
<pre id="the-merge" style="display:hidden;">
\begin{algorithm}
\caption{Merge}
\begin{algorithmic}
\INPUT An array and left, middle, and right locations in the array
\REQUIRE Sub-arrays from $p$ to $q$ and from $q + 1$ to $r$ are sorted
\OUTPUT The array with the two sections collated in order

\PROCEDURE{Merge}{$A, p, q, r$}

\STATE \textbf{The sizes of the sub-sections}
\STATE $n_1 \gets q - p + 1$
\STATE $n_2 \gets r - q$

\STATE \\ \textbf{Copy the subsections to new arrays.}
\STATE \textit{New arrays have one extra cell to hold a sentinel.}
\STATE $L \gets Array[0\ldots n_1]$
\STATE $R \gets Array[0 \ldots n_2]$

\FOR {$i \in {0 \ldots n_1 - 1}$}
  \STATE $L[i] \gets A[p + i - 1]$
\ENDFOR

\FOR{$j \in {0 \ldots n_2 - 1}$}
  \STATE $R[j] \gets A[q + j]$
\ENDFOR

\STATE \\ \textbf{Add sentinel to indicate end}
\STATE $L[n_1] \gets \infty $
\STATE $R[n_2] \gets \infty $

\STATE \\ \textbf{Collate}
\STATE $i \gets 0$
\STATE $j \gets 0$

\FOR {$k \in {p \ldots r}$}
 \IF {$L[i] \leq R[j]$}
   \STATE $A[k] \gets L[i]$
   \STATE $i' \gets i + 1$
 \ELSE
  \STATE $A[k] \gets R[j]$
  \STATE $j' \gets j + 1$
\ENDIF
\ENDFOR
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

One way to think about how the algorithm is like you have two stacks of cards, each of which is sorted and you want to merge them together in sorted order. Since they are already sorted, you only have to compare the top cards on the two stacks to each other, chose the lower card and put it in your output stack, and keep repeating this until you've moved all the cards from the two stacks to the output. If one stack runs out of cards you just move the other remaining cards onto the output stack.

Our algorithm starts by copying out the values from the source array into two new arrays to create our stacks. We append an \(\infty\) onto the end of each to simulate the emptying of the stack. Then we keep looking at the top item in each stack and copying the smaller item back into the original array. Because of the copying we are going over the input twice, but that is a relatively small (linear) increase.
** Implement It
#+begin_src python :results none
# python
from collections.abc import MutableSequence

# pypi
from expects import contain_exactly, equal, expect
#+end_src

#+begin_src python :results none
INFINITY = float("inf")
#+end_src

#+begin_src python :results none
def merge(collection: MutableSequence,
          left_start: int,
          left_end: int,
          right_end: int) -> int:
    """Merge the sub-sections from the collection

    Args:
     collection: list or array with sorted sub-sections
     left_start: index of start of first sub-section
     left_end: index of last item of first sub-section
     right_end: index of the last item of second sub-section
    """
    count = 0
    left_size = left_end - left_start + 1
    right_size = right_end - left_end
    right_start = left_end + 1

    left_stack = ([None] * left_size)
    right_stack = ([None] * right_size)
    
    for stack_location in range(left_size):
        left_stack[stack_location] = collection[left_start + stack_location]
        count += 1
        
    for stack_location in range(right_size):
        right_stack[stack_location] = collection[right_start + stack_location]
        count += 1

    left_stack.append(INFINITY)
    right_stack.append(INFINITY)

    next_left = next_right = 0

    for put_next_item_here in range(left_start, right_end + 1):
        count += 1
        if left_stack[next_left] <= right_stack[next_right]:
            collection[put_next_item_here] = left_stack[next_left]
            next_left += 1
        else:
            collection[put_next_item_here] = right_stack[next_right]
            next_right += 1
    return count
#+end_src

#+begin_src python :results none
first = list(range(5))
second = first[:]
collection = first + second

count = merge(collection, 0, 4, 9)

expect(count).to(equal(20))

expect(collection).to(contain_exactly(0,0,1,1,2,2,3,3,4,4))
#+end_src

#+begin_src python :results none
collection = [10] + first + second
count = merge(collection, 1, 5, 10)

expect(count).to(equal(20))

expect(collection[1:11]).to(contain_exactly(0,0,1,1,2,2,3,3,4,4))
#+end_src

#+begin_src python :results none
collection = [10] + first + second + [-1, 5]
count = merge(collection, 1, 5, 10)

expect(count).to(equal(20))

expect(collection[1:11]).to(contain_exactly(0,0,1,1,2,2,3,3,4,4))
#+end_src
** Runtime
Without doing anything fancy we can see that there's three for loops, the first two cover copying over all the sub-list items from the original list to the new lists, so together they execute once for every item (/n/ times). And the loop that does the actual merge also runs once for each item so it also runs /n/ times so altogether it has a run time of /2n/ which we'll say is $\Theta(n)$. This is actually going to be part of the merge-sort but I thought I'd put that in here since the post is separate.
* End
- {{% doc %}}clrs{{% /doc %}}

#+begin_export html
<script>
window.addEventListener('load', function () {
    pseudocode.renderElement(document.getElementById("the-merge"));
});
</script>
#+end_export
