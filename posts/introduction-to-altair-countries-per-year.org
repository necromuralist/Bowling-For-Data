#+BEGIN_COMMENT
.. title: Introduction To Altair: Bar Plot
.. slug: introduction-to-altair-bar-plot
.. date: 2024-03-06 16:57:41 UTC-08:00
.. tags: altair,bowling,visualization
.. category: Visualization
.. link: 
.. description: Continuing the Altair Introduction with a plot of the countries per year.
.. type: text
.. template: altair.tmpl
#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-f3d5e8a0-fd79-44a4-9a3c-f61352f1234b-ssh.json

#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC

* Setup
** Imports

These initial imports are supports to make creating this post easier and aren't necessarily needed for the altair plots.

#+begin_src python :results none
# python
from functools import partial
from pathlib import Path
from pprint import pprint

import json
import os
import re

# pypi
from dotenv import load_dotenv
from expects import be, be_true, equal, expect
from tabulate import tabulate

# monkey
from graeae.visualization.altair_helpers import output_path, save_vega_embed
#+end_src

These are the ones that are really needed for the plotting. I installed both of them through pypi.

#+begin_src python :results none
import altair
import pandas
#+end_src

** Some Setting Up

These are some convenience objects to save a little bit of coding when saving the chart.

#+begin_src python :results none
SLUG = "introduction-to-altair-bar-plot"
OUTPUT_PATH = output_path(SLUG)

HEIGHT, WIDTH = 600, 800
SAVE_IT = partial(save_vega_embed, output_path=OUTPUT_PATH)
#+end_src

This is to make printing out a pandas dataframe as a table a little nicer.

#+begin_src python :results none
TABLE = partial(tabulate,
                headers="keys",
                tablefmt="orgtbl",
                showindex=False)
#+end_src

* The Data

#+begin_src python :results output :exports both
load_dotenv(override=True)
table_path = Path(os.getenv("WORLD_HAPPINESS_TABLE"))

expect(table_path.is_file()).to(be_true)

table = pandas.read_csv(table_path)
print(table.shape)
#+end_src

#+RESULTS:
: (2199, 11)

** The Data Columns

#+begin_src python :results none
def column_printer(table, headers=("Column", "Type")):
    print(TABLE(
        ((column, str(table[column].dtype))
         for column in table.columns),
        headers=headers))
    return
#+end_src

#+begin_src python :results output :exports both
column_printer(table)
#+end_src

| Column                           | Type    |
|----------------------------------+---------|
| Country name                     | object  |
| year                             | int64   |
| Life Ladder                      | float64 |
| Log GDP per capita               | float64 |
| Social support                   | float64 |
| Healthy life expectancy at birth | float64 |
| Freedom to make life choices     | float64 |
| Generosity                       | float64 |
| Perceptions of corruption        | float64 |
| Positive affect                  | float64 |
| Negative affect                  | float64 |

For this initial post I'll only use the year.

#+begin_src python :results none
class Column:
    year = "year"
#+end_src

* Counting the Years
The dataset has entries for multiple years, each year having entries for different countries. They apparently weren't able to collect data from all countries for all years so the number of countries included changes with the year. As the first chart I'll plot counts for the number of rows in the data for each year.

** Using Pandas' ~value_counts~ Method

The first way I'll make the counts for each year is to use pandas' built in ~value_counts~ method, which creates a Series with the counts for each unique item in the column with the name given to it.

#+begin_src python :results none
year_counts = table.year.value_counts().reset_index().sort_values(Column.year)
#+end_src

By default it puts the "year" label into the index so I used ~reset_index~ to convert it to a column and then sorted it by year so we can get the data in chronological order. First, a table to get a sense of the values we're looking at.

#+begin_src python :results output :exports both
table_counts = year_counts.T
table_counts.columns = table_counts.iloc[0]
table_counts = table_counts.drop(table_counts.index[0])
print(TABLE(table_counts, showindex=True))
#+end_src

|       |   2005 |   2006 |   2007 |   2008 |   2009 |   2010 |   2011 |   2012 |   2013 |   2014 |   2015 |   2016 |   2017 |   2018 |   2019 |   2020 |   2021 |   2022 |
|-------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------|
| count |     27 |     89 |    102 |    110 |    114 |    124 |    146 |    141 |    136 |    144 |    142 |    141 |    147 |    141 |    143 |    116 |    122 |    114 |


Now as a bar-chart.

Since the years look like integers altair (well, vega) will assume that they're numbers but we want to think of them as labels instead so I'll tell it that it's a nominative column using their simplified string-based syntax.

#+begin_src python :results output :exports both
RANDOM_HEX = "a897e2c7"
YEAR_AS_NOMINATIVE = "{}:N".format(Column.year)

VALUE_COUNTS_NAME = "value-counts-bar-chart"
DIV_ID = VALUE_COUNTS_NAME + "-" + RANDOM_HEX

value_counts_chart = altair.Chart(year_counts).mark_bar().encode(
    x=YEAR_AS_NOMINATIVE,
    y="count").properties(height=HEIGHT, width=WIDTH)

VALUE_COUNTS_JS = VALUE_COUNTS_NAME + ".js"
SAVE_IT(value_counts_chart, name=VALUE_COUNTS_NAME, div_id=DIV_ID)
#+end_src

{{% altairdiv source="value-counts-bar-chart.js" divid="value-counts-bar-chart-a897e2c7" %}}

I saved the name of the javascript file that altair creates for a later section where I'll look at the file size.

** Using Altair's "count"

Although I normally use pandas to do value counts vega allows you to tell it to do different transformations of the data before plotting, including counting the values. This next plot will pass altair the original data and let it figure out the value counts.

#+begin_src python :results output :exports both
ALTAIR_COUNTS_NAME = "altair-counts-bar-chart"
DIV_ID = ALTAIR_COUNTS_NAME + "-" + RANDOM_HEX

altair_counts_chart = altair.Chart(table).mark_bar().encode(
    x=YEAR_AS_NOMINATIVE,
    y="count()").properties(height=HEIGHT, width=WIDTH)


ALTAIR_COUNTS_JS = ALTAIR_COUNTS_NAME + ".js"

SAVE_IT(altair_counts_chart, name=ALTAIR_COUNTS_NAME, div_id=DIV_ID)
#+end_src

{{% altairdiv source="altair-counts-bar-chart.js" divid="altair-counts-bar-chart-a897e2c7" %}}

#+begin_notecard
In case it isn't obvious, the difference between this plot and the prior one is I passed ~table~ to the ~Chart~ constructor and then told altair that the y-axis is ~"count()"~, meaning it should count the values for each unique entry in "x".
#+end_notecard

** Comparing the File Sizes

So, we have two ways to make the same plot - is there a reason to prefer one over the other? Well, given title of this section, you might guess that there's a difference in the size of the files created for the charts for each method which might make influence which one you choose.

*** The Files In Bytes

The charts shown above are created by having altair create a JSON object (the chart specification) which is passed to a (javascript) function created by [[https://github.com/vega/vega-embed][~vega-embed~]] in the browser. So if we look at the file-sizes for the charts, the difference will be in the size of the JSON created for each chart.

#+begin_src python :results output :exports both
altair_counts_html = OUTPUT_PATH/(ALTAIR_COUNTS_JS)
pandas_counts_html = OUTPUT_PATH/(VALUE_COUNTS_JS)
print("Altair counts(): {:,} bytes".format(altair_counts_html.stat().st_size))
print("Pandas value_counts: {:,} bytes".format(pandas_counts_html.stat().st_size))
#+end_src

#+RESULTS:
: Altair counts(): 684,749 bytes
: Pandas value_counts: 1,703 bytes

As you can see, letting altair count the data created a huge JSON object (compared to the pandas version). Altair acts as a translation layer between our python objects and vega. In the case where we tell altair that the y-axis uses ~"count()"~,  it means that altair converts our entire pandas DataFrame into JSON then passes it to the browser where vega does the counting. Even though our final chart only uses the "year" column and has one row per year, the javascript has all the original columns and rows.

To get a better idea of what this means let's look at one entry from each of the charts' data. The ~Chart.to_dict~ method gives us the same key-value pairs as the JSON object that's passed to vega, but, more conveniently since I'm using python here, as a python dictionary.

#+begin_src python :results output :exports both
value_counts_dict = value_counts_chart.to_dict()
print(value_counts_dict.keys())
#+end_src

#+RESULTS:
: dict_keys(['config', 'data', 'mark', 'encoding', 'height', 'width', '$schema', 'datasets'])

You might think that the "data" key holds our data, but it actually holds the key for our data which is in the dictionary matched to the "datasets" key.

#+begin_src python :results output :exports both
print(value_counts_dict["data"])
print(value_counts_dict["datasets"].keys())
#+end_src

#+RESULTS:
: {'name': 'data-774be733c0ac4b1e0a7bf95a840a22e6'}
: dict_keys(['data-774be733c0ac4b1e0a7bf95a840a22e6'])

The pandas data is represented as a row of dictionaries in the "datasets" dictionary.

#+begin_src python :results output :exports both
name = value_counts_dict["data"]["name"]
frame = value_counts_dict["datasets"][name]
print(frame)
#+end_src

#+RESULTS:
: [{'year': 2005, 'count': 27}, {'year': 2006, 'count': 89}, {'year': 2007, 'count': 102}, {'year': 2008, 'count': 110}, {'year': 2009, 'count': 114}, {'year': 2010, 'count': 124}, {'year': 2011, 'count': 146}, {'year': 2012, 'count': 141}, {'year': 2013, 'count': 136}, {'year': 2014, 'count': 144}, {'year': 2015, 'count': 142}, {'year': 2016, 'count': 141}, {'year': 2017, 'count': 147}, {'year': 2018, 'count': 141}, {'year': 2019, 'count': 143}, {'year': 2020, 'count': 116}, {'year': 2021, 'count': 122}, {'year': 2022, 'count': 114}]

Since the altair ~counts()~ version is so large let's make a function to pull out one entry from each of the datasets just to show how the data is passed to vega.

#+begin_src python :results none
def data_print(chart, index: int=0) -> None:
    """Print an entry in the data

    Params
     - `chart`: chart with data to print
     - `index`: index of data item to print
    """
    KEY = "datasets"

    chart_data = chart.to_dict()[KEY]
    data_key = list(chart_data.keys())[0]
    data = chart_data[data_key]
    print("Number of Entries in the Data: {:,}".format(len(data)))
    print("Item {}: \n".format(index))
    pprint(data[index])
    return
#+end_src

I already showed the ~value_counts_chart~ data above, but, let's do it again so we can compare it directly to the ~altair_counts_chart~ data.

#+begin_src python :results output :exports both
data_print(value_counts_chart)
#+end_src

#+RESULTS:
: Number of Entries in the Data: 18
: Item 0: 
: 
: {'count': 27, 'year': 2005}

So the "dataset" passed to vega has 18 entries (one per year in our ~year_counts~ DataFrame) and the first entry matches the first row in that DataFrame. Now let's look at the dictionary for the JSON passed to vega to create the counts.

#+begin_src python :results output :exports both
data_print(altair_counts_chart)
#+end_src

#+RESULTS:
#+begin_example
Number of Entries in the Data: 2,199
Item 0: 

{'Country name': 'Afghanistan',
 'Freedom to make life choices': 0.718,
 'Generosity': 0.168,
 'Healthy life expectancy at birth': 50.5,
 'Life Ladder': 3.724,
 'Log GDP per capita': 7.35,
 'Negative affect': 0.258,
 'Perceptions of corruption': 0.882,
 'Positive affect': 0.414,
 'Social support': 0.451,
 'year': 2008}
#+end_example

#+begin_src python :results output :exports both
print("{:,}".format(len(table)))
#+end_src

#+RESULTS:
: 2,199

As expected, altair converted our entire ~table~ DataFrame to JSON and passed it to vega for the second chart, inflating the amount of text sent to the browser a bit. It might or might not make a difference in this broadband world, but it's something to be aware of if you put multiple charts into one page or have a really large data set.

See the [[https://altair-viz.github.io/user_guide/large_datasets.html][altair documentation on Large Datasets]] for more information.
* A Chart, Part By Part

** Altair's Chart

#+begin_src python :results output :exports both
chart = altair.Chart(year_counts)
print(type(chart))
expect(chart.data).to(be(year_counts))
#+end_src

#+RESULTS:
: <class 'altair.vegalite.v5.api.Chart'>

The ~Chart~ class is defined in ~altair.vegalite.v5.api~. This is its docstring description:

#+begin_quote
Create a basic Altair/Vega-Lite chart.


Although it is possible to set all Chart properties as constructor attributes,
it is more idiomatic to use methods such as ~mark_point()~, ~encode()~,
~transform_filter()~, ~properties()~, etc. See Altair's documentation
for details and examples: http://altair-viz.github.io/.
#+end_quote

The attributes set by the ~Chart~ class' constructor (it also accepets other keyword parameters that are passed to its parent classes) are:

 - data
 - encoding
 - mark
 - width
 - height

By default they're set to ~Undefined~ which is an altair-defined object (see ~altair.utils.schemapi~), and as noted, you don't normally set the attributes using the constructor (other than ~data~ which isn't mentioned in the docstring but appears to be passed to the ~Chart~ constructor by convention).

Here's a diagram of the ~Chart~ (defined in ~altair.vegalite.v5.api~).

#+begin_src plantuml :file ../files/posts/introduction-to-altair-bar-plot/chart.png :exports none
!theme mars

class Chart {
 + data: DataFrameLike
 + encoding: core.FacetedEncoding
 + mark: str
 + width: int
 + height: int

 + from_dict():  core.SchemaBase
 + to_dict(): dict
 + transformed_data(): DataFrameLike
 + add_params(): Chart
 + interactive(): Chart
}

TopLevelMixin <|-- Chart
_EncodingMixin <|-- Chart
mixin.MarkMethodMixin <|-- Chart
core.TopLevelUnitSpec <|-- Chart
#+end_src

#+RESULTS:
[[file:../files/posts/introduction-to-altair-bar-plot/chart.png]]

[[img-url:chart.png]]

** A Bar Chart

Once we have a chart object we tell altair that we want it to be a bar chart using the ~mark_bar~ method.

#+begin_src python :results output :exports both
bar_chart = chart.mark_bar()
print(type(bar_chart))
#+end_src

#+RESULTS:
: <class 'altair.vegalite.v5.api.Chart'>


The ~mark_~ methods are defined in the ~MarkMethodMixin~ class (a parent of ~Chart~) which is defined in ~altair.vegalite.v5.schema.mixins~ module.

#+begin_src plantuml :file ../files/posts/introduction-to-altair-bar-plot/mark-mixin.png :exports none
!theme mars

class MarkMethodMixin {

mark_arc(): Self
mark_area(): Self
mark_bar(): Self
mark_boxplot(): Self
mark_circle(): Self
mark_errorband(): Self
mark_errorbar(): Self
mark_geoshape(): Self
mark_image(): Self
mark_line(): Self
mark_point(): Self
mark_rect(): Self
mark_rule(): Self
mark_square(): Self
mark_text(): Self
mark_tick(): Self
mark_trail(): Self
}
#+end_src

#+RESULTS:
[[file:../files/posts/introduction-to-altair-bar-plot/mark-mixin.png]]

[[img-url:mark-mixin.png][MarkMixin Class]]

Looking in the ~mark_bar~ method, there's a lot of arguments you could pass to it, but fundamentally all it's really doing is making a copy of itself, setting the ~mark~ attribute to ~bar~ and then returning the copy.


#+begin_src python :results output :exports both
print("Original Chart mark: '{}'".format(chart.mark))
print("Bar Chart mark: '{}'".format(bar_chart.mark))

expect(bar_chart).to_not(be(chart))
#+end_src

#+RESULTS:
: Original Chart mark: 'Undefined'
: Bar Chart mark: 'bar'

** SchemaBase

~altair.utils.schemapi~.

#+begin_src plantuml :file ../files/posts/introduction-to-altair-bar-plot/schema-base.png :exports none
!theme mars

class SchemaBase {

+ copy(): Self
}
#+end_src

#+RESULTS:
[[file:../files/posts/introduction-to-altair-bar-plot/schema-base.png]]

[[img-url:schema-base.png]]

There are many more methods in ~altair.utils.schemapi.SchemaBase~ but I'm highlighting ~copy~ here because it gets used quite a bit by the other classes but is defined in this somewhat obscure place. The behavior is what you'd expect so I don't see a need to go over it, but it's one of those mystery methods that just pops up when you use deep inheritance like this that makes you wonder what's going on so I'll document it here, for now.

*** TopLevelUnitSpec

If you look at the parents of the ~Chart~ you might notice that it doesn't have the ~SchemaBase~ as one of its parents. So how does it end up with the ~copy~ method? Well, it does have the ~core.TopLevelUnitSpec~ as one of its parents and that in turn (eventually) inherits from the ~SchemaBase~.

#+begin_src plantuml :file ../files/posts/introduction-to-altair-bar-plot/top-level-unit-spec.png :exports none
!theme mars

altair.utils.schemapi.SchemaBase <|-- core.VegaLiteSchema
VegaLiteSchema <|-- core.TopLevelSpec
TopLevelSpec <|--core.TopLevelUnitSpec
#+end_src

#+RESULTS:
[[file:../files/posts/introduction-to-altair-bar-plot/top-level-unit-spec.png]]

[[img-url:top-level-unit-spec.png]]

I didn't put in the modules for the ~core~ classes since they are fairly deep.

** Encoded

The ~encode~ method is where we tell ~altair~ which columns match which parts of the chart. In this case we're only setting the /x/ and /y/ axes.

#+begin_src python :results output :exports both
encoded = bar_chart.encode(
    x="{}:N".format(Column.year),
    y="count")

print(type(encoded))
#+end_src

#+RESULTS:
: <class 'altair.vegalite.v5.api.Chart'>

*** _EncodingMixin

The ~encode~ method is defined in the ~_EncodingMixin~ class, one of the ~Chart~'s parents.

#+begin_src plantuml :file ../files/posts/introduction-to-altair-bar-plot/encoding-mixin.png :exports none
!theme mars

class _EncodingMixin {
  encode(*args, **kwargs): Self
}
#+end_src

#+RESULTS:
[[file:../files/posts/introduction-to-altair-bar-plot/encoding-mixin.png]]

[[img-url:encoding-mixin.png]]

The ~encoding~ method takes in whatever combination of positional and keyword arguments you pass into it and then:

 - copies the Chart
 - updates the chart's ~encoding~ attribute
 - sets the copy's ~encoding~ attribute to an instance of the ~altair.vegalite.v5.schema.FacetedEncoding~ class.
 - returns the copy

#+begin_src python :results output :exports both
print(encoded.encoding)
#+end_src

#+RESULTS:
: FacetedEncoding({
:   x: X({
:     shorthand: 'year:N'
:   }),
:   y: Y({
:     shorthand: 'count'
:   })
: })


** Properties

#+begin_src python :results output :exports both
propertied = encoded.properties(height=HEIGHT, width=WIDTH)
print(type(propertied))
#+end_src

#+RESULTS:
: <class 'altair.vegalite.v5.api.Chart'>

#+begin_src plantuml :file ../files/posts/introduction-to-altair-bar-plot/top-level-mixin.png :exports none
!theme mars

class TopLevelMixin {
  to_dict(validate, *, format, ignore, context): dict
  to_json(validate, indent, sort_keys, *, format, ignore, context, **kwargs) : str
  to_html(base_url, output_div, embed_options, json_kwds, fullhtml, requirejs, inline, **kwargs): str
  to_url(*, fullscreen): str

  properties(**kwargs) : Self
  save(fp, format, override_data_transformer, scale_factor, mode, vegalite_version, vega_version, vegaembed_version, embed_options, json_kwds, webdriver, engine, inline, **kwargs): None
}

mixins.ConfigMethodMixin <|-- TopLevelMixin
#+end_src

#+RESULTS:
[[file:../files/posts/introduction-to-altair-bar-plot/top-level-mixin.png]]

[[img-url:top-level-mixin.png]]

#+begin_quote
**Note:** This is a huge class with more methods than I'm showing here. The only ones we've encountered so far are ~to_dict~, ~save~ and ~properties~. I used ~to_dict~ to show that the chart has all the data from the pandas DataFrame and ~save~ is buried in the code that saves the chart to display it in this post - ~properties~ is the only one we're really interested in here.
#+end_quote

The first thing to note about the ~properties~ method is that it doesn't define any arguments, it takes in any keyword arguments (and only keyword arguments, no positional arguments) and values for the arguments. Then:

 - it makes a copy of the chart
 - validates the arguments (unless the argument is the ~data~)
 - sets the arguments as attributes of the copy.
 - returns the copy

Since we passed in ~height~ and ~width~ to the ~properties~ method, we get back a copy of our bar chart with the ~height~ and ~width~ set on the copy (as well as the "mark" which we set earlier with ~mark_bar~).

#+begin_src python :results output :exports both
print(propertied.mark)
print(propertied.width)
print(propertied.height)
expect(propertied.mark).to(equal("bar"))
expect(propertied.width).to(equal(WIDTH))
expect(propertied.height).to(equal(HEIGHT))
#+end_src

#+RESULTS:
: bar
: 800
: 600

* HVPlot
* Links
** The Posts In This Series

- {{% lancelot "Starting Post" %}}introduction-to-altair{{% /lancelot %}}

** Tutorial Sources
- [[https://www.coursera.org/learn/fundamentals-of-data-visualization/home/week/1][/Fundamentals of Visualization with Dr. Danielle Albers Szafir/]]: Coursera course where the original tutorial came from.
- [[https://infovis.fh-potsdam.de/tutorials/][InfoVis Course from Marian Dork]]: Iniversity of Applied Sciences Potsdam that the Coursera course cites as the source for their tutorial.
** The Data
- World Happiness Report Dataset [Internet]. [cited 2023 Dec 11]. Available from: https://www.kaggle.com/datasets/unsdsn/world-happiness
- Inc G. Gallup.com. 2009 [cited 2023 Dec 11]. Understanding How Gallup Uses the Cantril Scale. Available from: https://news.gallup.com/poll/122453/Understanding-Gallup-Uses-Cantril-Scale.aspx
- World Happiness Report [Internet]. 2023 [cited 2023 Dec 11]. Available from: https://worldhappiness.report/

** Altair
- Layered and Multi-View Charts — Vega-Altair 5.2.0 documentation [Internet]. [cited 2023 Dec 12]. Available from: https://altair-viz.github.io/user_guide/compound_charts.html
- Large Datasets — Vega-Altair 5.2.0 documentation [Internet]. [cited 2024 Mar 8]. Available from: https://altair-viz.github.io/user_guide/large_datasets.html
- vega/vega-embed [Internet]. Vega; 2024 [cited 2024 Mar 16]. Available from: https://github.com/vega/vega-embed
  
