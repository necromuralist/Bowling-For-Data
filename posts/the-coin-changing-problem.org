#+BEGIN_COMMENT
.. title: The Coin Changing Problem
.. slug: the-coin-changing-problem
.. date: 2022-06-16 15:11:33 UTC-07:00
.. tags: dynamic programming,greedy,algorithms
.. category: Dynamic Programming
.. link: 
.. description: 
.. type: text
.. has_pseudocode: yes
#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-1f57c53d-4401-4217-ba41-9eb3a439ec28-ssh.json
#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
* The Change Problem
The /Change Problem (Coin Changing Problem)/ asks us to convert some amount of money into denominations using the fewest coins.

**Input:** An integer (/money/) and an array of /d/ denominations (\(c = c_1, c_2, \ldots, c_d\)) in decreasing order of value (\(c_1 > c_2> \cdots > c_d\)).

**Output:** A list of /d/ integers \(i_1, i_2, \ldots, i_d\) such that \(c_1 \cdot i_1 + c_2 \cdot i_2 + \cdots + c_d \cdot i_d = money\)  and \(i_1 + i_2 + \cdots + i_d\) is as small as possible.
* SetUp
** Imports
#+begin_src python :results none
# python
from collections import namedtuple
from functools import partial

# pypi
from expects import contain_exactly, expect, equal

import altair
import pandas

# my stuff
from graeae.visualization.altair_helpers import output_path, save_chart
#+end_src

** Setup
#+begin_src python :results none
ChangeCounts = namedtuple("ChangeCounts", ["coin_counts", "run_count"])

SLUG = "the-coin-changing-problem"
OUTPUT_PATH = output_path(SLUG)
save_it = partial(save_chart, output_path=OUTPUT_PATH)
#+end_src
* The Cashier's Algorithm
The way many cashier's make change for customers is using a greedy approach.

** Pseudocode
#+begin_export html
<pre id="cashiers-algorithm" style="display:hidden;">
\begin{algorithm}
\caption{CashiersChange}
\begin{algorithmic}
\INPUT Amount owed ($money$) and a supply of coins ($c$).
\PROCEDURE{CashiersChange}{$money, c$}
\WHILE {\(money > 0\)}
  \STATE \(coin \gets\) Coin with the largest denomination that doesn't exceed \(money\).
  \STATE Give $coin$ to the customer.
  \STATE \(money \gets money - coin\)
\ENDWHILE
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

** Python Implementation
#+begin_src python :results none
def cashier_changer(amount: int, denominations: list) -> ChangeCounts:
    """Implements the cashier's method for making change

    Args:
     amount: the value of the change needed
     denominations: values for coins (in descending order)

    Returns:
     list of coin-counts, number of loops ran
    """
    coins = [0] * len(denominations)
    remainder = amount
    loop_count = 0

    for index, denomination in enumerate(denominations):
        coin_count = 0
        while denomination <= remainder:
            coin_count += 1
            loop_count += 1
            remainder = remainder - denomination

        coins[index] = coin_count
    return ChangeCounts(coin_counts=coins, run_count=loop_count)
#+end_src

*** A First Test
Examples from {{% lancelot "LATPAPS" %}}LATPAPS{{% /lancelot %}}.

#+begin_src python :results none
def check_coins(answer: list, denominations: list,
                expected_coins: int,
                expected_total: int) -> None:
    """Check that our answer matches the expected

    Args:
     answer: list of counts for each denomination
     denominations: list of coin denominations available
     expected_coins: the expected list of counts for each denomination
     expected_total: what the value our coins should add up to

    Raises:
     AssertionError: something about our answer doesn't match the expected
    """
    expect(sum(answer)).to(equal(sum(expected_coins)))
    expect(answer).to(contain_exactly(*expected_coins))
    expect(sum(count * coin for count, coin in zip(answer, denominations))).to(
        equal(expected_total)
    )
    return
#+end_src

#+begin_src python :results output :exports both
# case 1
money = 2
coins = [10, 5, 1]
actual = cashier_changer(money, coins)
check_coins(actual.coin_counts, coins, [0, 0, 2], money)
print(f"case 1: {actual.run_count}")

# case 2
money = 28
actual = cashier_changer(money, coins)
check_coins(actual.coin_counts, coins, [2, 1, 3], money)
print(f"case 2: {actual.run_count}")

# case 3
money = 99
actual = cashier_changer(money, coins)
check_coins(actual.coin_counts, coins, [9, 1, 4], money)
print(f"case 2: {actual.run_count}")
#+end_src

#+RESULTS:
: case 1: 2
: case 2: 6
: case 2: 14

The number of loops is dependent on the change owed, with an upper limit based on the denominations. In this case if we assume you wouldn't give out more than 99 cents in change then we would cap out at \( 9 \times 10 + 1 \times 5 + 4 \times 1\) = 14 coins/loops.

*** U.S. Denominations
This is a quick check using the U.S. coins most commonly used by cashiers. By adding a 25 cent piece we reduce the upper limit on the amount of coins needed to \(3 \times 25 + 2 \times 10 + 4 \times 1\) = 9 coins.

#+begin_src python :results none
coins = [25, 10, 5, 1]

money = 28
actual = cashier_changer(money, coins)
check_coins(actual.coin_counts, coins, [1, 0, 0, 3], money)

money = 14
actual = cashier_changer(money, coins)
check_coins(actual.coin_counts, coins, [0, 1, 0, 4], money)
#+end_src

** Plotting the Coin Counts/Loops

#+begin_src python :results output :exports both
amounts = list(range(1, 100))
counts = [cashier_changer(amount, coins).run_count for amount in amounts]

frame = pandas.DataFrame({"Amount to Change": amounts, "Coins": counts})

chart = altair.Chart(frame).mark_bar().encode(
    x="Amount to Change",
    y="Coins", tooltip=["Amount to Change", "Coins"]).properties(
        title="Cashier's Change Coin Counts (Common U.S. Coins)",
        width=800,
        height=525,
    )

save_it(chart, "cashiers-change-us-coins")
#+end_src

#+RESULTS:
#+begin_export html
<object type="text/html" data="cashiers-change-us-coins.html" style="width:100%" height=600>
  <p>Figure Missing</p>
</object>
#+end_export

*** The Double-Dime
Looking at the cashier-algorithm you can see that it only has one loop that traverses the denominations of coins - so it is a very quick algorithm, but while our cashier algorithm turns out to work for the specific set of coins that cashiers use, will that always be the case?

According to Wikipedia, there was at one time a proposal in the United States for a [[https://en.wikipedia.org/wiki/Twenty-cent_piece_(United_States_coin)][twenty-cent piece]]. If we include the twenty cent piece amongst our denominations, we find that there are cases where the cashier algorithm will miss the optimal solution.

#+begin_src python :results output :exports both
coins = [25, 20, 10, 5, 1]

money = 40
actual = cashier_changer(money, coins)

try:
    check_coins(actual.coin_counts, coins, [0, 2, 0, 0, 0], money)
except AssertionError as error:
    print(f"AssertionError: {error}")
#+end_src

#+RESULTS:
: AssertionError: 
: expected: 3 to equal 2

Because the cashier algorithm always takes the largest possible coins first, it ends up using 25¢ + 10¢ + 5¢ as the solution instead of the optimal 20¢ + 20¢. While it might seem artificial, given the characterization of this as a solution to making change, it's important to note that generalizing the cashier algorithm beyond the curated denominations or even beyond coins specifically leaves it vulnerable to cases where it will fail.

* A Greedy Version
As noted, the Cashier's Algorithm is a greedy algorithm, but let's translate it into a silghtly smarter version which uses a little arithmetic to get to the same point.

** In Pseudocode
#+begin_export html
<pre id="greedy-algorithm" style="display:hidden;">
\begin{algorithm}
\caption{GreedyChange}
\begin{algorithmic}
\INPUT An integer ($money$) and an array of $d$ denominations (\(c = c_1, c_2, \ldots, c_d\)) in decreasing order of value (\(c_1 > c_2> \cdots > c_d\)).
\OUTPUT A list of $d$ integers \(i_1, i_2, \ldots, i_d\) such that \(c_1 \cdot i_1 + c_2 \cdot i_2 + \cdots + c_d \cdot i_d = money\)  and \(i_1 + i_2 + \cdots + i_d\) is as small as possible.
\PROCEDURE{CashiersChange}{$money, c$}
\STATE $remainder \gets money$
\STATE $d \gets $ \textsc{Length}($c$)
\FOR {$k \in \{1 \ldots d\}$}
  \STATE $i_k \gets \lfloor \frac{remainder}{c_k} \rfloor$
  \STATE $remainder \gets remainder - c_k \cdot i_k$
\ENDFOR
\RETURN $(i_1, i_2, \ldots, i_d)$
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export
** In Python
#+begin_src python :results none
def greedy_changer(money: int, denominations: list) -> ChangeCounts:
    """Make change using the fewest coins

    Args:
     money: the amount to change
     denominations: list of coin denominations in decreasing order

    Returns:
     Number of each denomination needed to make the change, loop-count
    """
    coins = [0] * len(denominations)
    remainder = money
    count = 0
    for location, denomination in enumerate(denominations):
        coins[location] = remainder // denomination
        remainder = remainder - denomination * coins[location]
        count += 1
    return ChangeCounts(coins, count)
#+end_src

** Testing It Out
*** A First Test

#+begin_src python :results none
# case 1
money = 2
coins = [10, 5, 1]
actual = greedy_changer(money, coins)
check_coins(actual.coin_counts, coins, [0, 0, 2], money)

# case 2
money = 28
actual = greedy_changer(money, coins)
check_coins(actual.coin_counts, coins, [2, 1, 3], money)
#+end_src

*** U.S. Denominations
#+begin_src python :results none
coins = [25, 10, 5, 1]

money = 28
actual = greedy_changer(money, coins)
check_coins(actual.coin_counts, coins, [1, 0, 0, 3], money)

money = 14
actual = greedy_changer(money, coins)
check_coins(actual.coin_counts, coins, [0, 1, 0, 4], money)
#+end_src

*** The Double-Dime
Looking at the greedy-algorithm you can see that it only has one loop that traverses the denominations of coins - so it is a very quick algorithm, but while our greedy algorithm turns out to work for the specific set of coins that cashiers use, will that always be the case?

According to Wikipedia, there was at one time a proposal in the United States for a [[https://en.wikipedia.org/wiki/Twenty-cent_piece_(United_States_coin)][twenty-cent piece]]. If we include the twenty cent piece amongst our denominations, we find that there are cases where the greedy algorithm will miss the optimal solution.

#+begin_src python :results output :exports both
coins = [25, 20, 10, 5, 1]

money = 40
actual = greedy_changer(money, coins)

try:
    check_coins(actual.coin_counts, coins, [0, 2, 0, 0, 0], money)
except AssertionError as error:
    print(f"AssertionError: {error}")
#+end_src

#+RESULTS:
: AssertionError: 
: expected: 3 to equal 2

Because the greedy algorithm always takes the largest possible coins first, it ends up using 25¢ + 10¢ + 5¢ as the solution instead of the optimal 20¢ + 20¢. While it might seem artificial, given the characterization of this as a solution to making change, it's important to note that generalizing the greedy algorithm beyond the curated denominations or even beyond coins specifically leaves it vulnerable to cases where it will fail.

** Plotting
#+begin_src python :results output :exports both
amounts = list(range(1, 100))
cashier_counts = [cashier_changer(amount, coins).run_count for amount in amounts]
greedy_counts = [greedy_changer(amount, coins).run_count for amount in amounts]
frame = pandas.DataFrame({"Amount to Change": amounts,
                          "Greedy": greedy_counts,
                          "Cashier": cashier_counts})
melted= frame.melt(id_vars=["Amount to Change"],
                   value_vars=["Greedy", "Cashier"],
                   var_name="Change Method",
                   value_name="Loop Count")

chart = altair.Chart(melted).mark_line(point=True).encode(
    x="Amount to Change",
    y="Loop Count",
    tooltip=["Amount to Change", "Loop Count", "Change Method"],
    color="Change Method").properties(
        title="Cashier's and Greedy Change Coin Counts (Common U.S. Coins)",
        width=800,
        height=525,
    )

save_it(chart, "cashiers-greedy-change-us-coins")
#+end_src

#+RESULTS:
#+begin_export html
<object type="text/html" data="cashiers-greedy-change-us-coins.html" style="width:100%" height=600>
  <p>Figure Missing</p>
</object>
#+end_export

* A Brute Force Changer
{{% lancelot "LATPAPS" %}}latpaps{{% /lancelot %}} has some pseudocode for a Brute-Force Change maker but they use some pseudocode notation that I'm not familiar with and, while it doesn't seem like it's too obtuse, working it out seemed harder than writing some python so this is a rough change-finder that tries all the possible change counts to find the best.

#+begin_src python :results none
def brute_changer(money: int, denominations: list) -> list:
    """Make change using the fewest coins

    Args:
     money: the amount to change
     denominations: list of coin denominations in decreasing order

    Returns:
     Number of each denomination needed to make the change
    """
    best = float("inf")
    number_of_denominations = len(denominations)

    for first in range(number_of_denominations):
        remainder = money
        counts = [0] * number_of_denominations
        total = 0
        for next_location in range(first, number_of_denominations):
            denomination = denominations[next_location]
            count = remainder//denomination
            remainder = remainder - count * denomination
            counts[next_location] = count
            total += count
        if total < best:
            best_counts = counts
            best = total
    return best_counts
#+end_src

#+begin_src python :results none
# case 1
money = 2
coins = [10, 5, 1]
actual = brute_changer(money, coins)
check_coins(actual, coins, [0, 0, 2], money)

# case 2
money = 28
actual = brute_changer(money, coins)
check_coins(actual, coins, [2, 1, 3], money)

coins = [25, 10, 5, 1]

money = 28
actual = brute_changer(money, coins)
check_coins(actual, coins, [1, 0, 0, 3], money)

money = 14
actual = brute_changer(money, coins)
check_coins(actual, coins, [0, 1, 0, 4], money)
#+end_src

#+begin_src python :results none
coins = [25, 20, 10, 5, 1]

money = 40
actual = brute_changer(money, coins)

check_coins(actual, coins, [0, 2, 0, 0, 0], money)
#+end_src

The Brute-Force Changer fixes our double-dimes case, but our runtime estimate is once again:

\[
T(n) = \sum_{i = 1}^{n} = \frac{n(n + 1)}{2} \implies \Theta(n^2)
\]

Given how few denominations a person is likely to encounter this doesn't seem so bad, but this is meant to illustrate greedy versus brute-force versus dynamic programming to make it easier to generalize the concepts with other, possibly harder, problems.
* Memoized Changer
#+begin_src python :results none
def memoized_changer(money: int, denominations: list, table: dict) -> list:
    """Make change using the fewest coins

    Args:
     money: the amount to change
     denominations: list of coin denominations in decreasing order
     table: memoization table (largest denomination, amount to change): best coin counts

    Returns:
     Number of each denomination needed to make the change
    """
    if money == 0:
        return [0] * len(denominations)
    if (denominations[0], money) in table:
        return table[(denominations[0], money)]
    
    last_denomination = len(denominations) - 1
    best = float("inf")
    best_counts = None

    for current, denomination in enumerate(denominations):
        count = money//denomination
        remaining = money - count * denomination

        if current == last_denomination:
            if remaining > 0:
                count = float("inf")
            counts = [count]
        else:
            counts = [count] + memoized_changer(
                remaining, denominations[current + 1:], table)

        total_counts = sum(counts)
        if total_counts < best:
            best = total_counts
            best_counts = [0] * current + counts
        table[(denomination, money)] = counts
    return best_counts
#+end_src

#+begin_src python :results none
table = {}
money = 2
coins = [10, 5, 1]
actual = memoized_changer(money, coins, table)

#+end_src

#+begin_src python :results none
# case 1
money = 2
coins = [10, 5, 1]
actual = memoized_changer(money, coins, {})
check_coins(actual, coins, [0, 0, 2], money)

# case 2
money = 28
actual = memoized_changer(money, coins, {})
check_coins(actual, coins, [2, 1, 3], money)

coins = [25, 10, 5, 1]

money = 28
actual = memoized_changer(money, coins, {})
check_coins(actual, coins, [1, 0, 0, 3], money)

money = 14
actual = memoized_changer(money, coins, {})
check_coins(actual, coins, [0, 1, 0, 4], money)
#+end_src

#+begin_src python :results none
coins = [25, 20, 10, 5, 1]

money = 40
table = {}
actual = memoized_changer(money, coins, table)

check_coins(actual, coins, [0, 2, 0, 0, 0], money)
#+end_src

* Sources
- [LATPAPS] {{% doc %}}LATPAPS{{% /doc %}}

#+begin_export html
<script>
window.addEventListener('load', function () {
    pseudocode.renderElement(document.getElementById("cashiers-algorithm"));
});
</script>
#+end_export

#+begin_export html
<script>
window.addEventListener('load', function () {
    pseudocode.renderElement(document.getElementById("greedy-algorithm"));
});
</script>
#+end_export

