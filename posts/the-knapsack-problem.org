#+BEGIN_COMMENT
.. title: The Knapsack Problem
.. slug: the-knapsack-problem
.. date: 2022-06-27 12:42:46 UTC-07:00
.. tags: algorithms,optimization
.. category: Optimization
.. link: 
.. description: A look at the Knapsack Problem
.. type: text
.. has_pseudocode: yes
#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-09f23e8c-9aa7-46f7-a2a1-73490b755ae4-ssh.json
#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
* The Knapsack Problem(s)
The basic premise of the /Knapsack Problem/ is that we have a knapsack with a maximum capacity (/C/) and a selection of /n/ items, each item having a weight (\(w_i\)) and a value (\(v_i\)), and we want to pick the items that give us the most total value without exceeding the capacity of our knapsack.

There are two forms of the problem. The first form is what {{% lancelot "CLRS" %}}clrs{{% /lancelot %}} 
calls the \(\textit{0-1 Knapsack Problem}\) because we can either take the item ($1$) or not take the item ($0$) as opposed to the \(\textit{Fractional Knapsack Problem}\) where the "items" are things that we can take fractional portions of (if we're loading up on spices the \(\textit{0-1}\) problem might be pre-packaged spices while the \(\textit{fractional}\) problem involves scooping spices out of the bulk bins).

Although the problems look more or less the same, the fractional problem is one that can be solved using a greedy algorithm while the 0-1 problem can fail if you use a greedy approach so the all-or-nothing version is the more interesting case and the one we'll look at here.

** Imports
#+begin_src python :results none
# python
from collections import namedtuple

# pypi
from expects import (be_below_or_equal, contain_exactly, equal, expect,
                     raise_error)
#+end_src

** Setup
#+begin_src python :results none
Solution = namedtuple("Solution", "value inventory count")
TableSolution = namedtuple("TableSolution", "value inventory count table")
NEGATIVE_INFINITY = float("-inf")
#+end_src
* The Brute Force Solution
One way to find the optimal load for our knapsack is to find all the possible loads and taking the best load from those that will fit in the knapsack. This requires us to calculate the values for {{% lancelot "every subset" %}}number-of-subsets-in-a-set{{% /lancelot %}} of items which means we'll have to do \(2^n\) calculations.

** An Iterative Brute-Force Version
To have a reference solution I'll make a brute-force iterative version of the knapsack solver. This will have a greater runtime (\(n 2^n\)) but sometimes starting with something easy is useful, even if it's not a practical solution.

#+begin_src python :results none
def brute_knapsack(capacity: int, values: list, weights: list) -> Solution:
    """Finds the best selection of items to maximize value
    
    Args:
     capacity: maximum weight allowed
     values: value for each item available
     weights: how much each item weighs

    Returns:
     best-value, count of each item, count of loops
    """
    assert len(values) == len(weights)

    number_of_items = len(values)
    items = [0] * number_of_items
    best_value = 0
    count = 0

    for combination in range(2**(number_of_items)):
        value, weight, carry = 0, 0, 1
        for item in range(number_of_items):
            increment = items[item] + carry
            keep = increment % 2
            carry = increment//2
            if keep:
                value += values[item]
                weight += weights[item]
            items[item] = keep
            count += 1
        if weight <= capacity and value > best_value:
            best_value = value
            solution = items[:]

    return Solution(value=best_value, inventory=solution, count=count)
    
#+end_src

** Checking the Brute
#+begin_src python :results none
def check_solution(solution: Solution,
                   expected_inventory: list,
                   values: list, weights: list, capacity: int):
    """Check that the solution matches the expected

    Args:
     solution: namedtuple with the knapsack solution
     expected_inventory: list of 0's and 1's representing which items to keep
     expected_value: total value expected for the solution
     values: values for the items
     weights: weights for the items
     capacity: maximum weight for the knapsack

    Raises:
     AssertionError if something isn't the expected
    """
    expect(solution.inventory).to(contain_exactly(*expected_inventory))
    value = sum([loot for index, loot in enumerate(values)
                 if solution.inventory[index]])
    weight = sum([poundage for index, poundage in enumerate(weights)
                  if solution.inventory[index]])

    expected_value = sum([loot for index, loot in enumerate(values)
                          if expected_inventory[index]])
    expect(value).to(equal(expected_value))
    expect(weight).to(be_below_or_equal(capacity))
    return
#+end_src

#+begin_src python :results none
def check_examples(solver: object) -> None:
    """Check the toy examples

    Args:
     solver: function to find the optimal knapsack load
    """
    # values and weights don't match
    broken = lambda : solver(5, [0, 1], [2, 1, 3])
    expect(broken).to(raise_error(AssertionError))

    capacity = 10
    values = [42, 12, 40, 25]
    weights = [7, 3, 4, 5]
    expected = [0, 0, 1, 1]

    solution = solver(capacity, values, weights)
    check_solution(solution, expected, values, weights, capacity)

    capacity = 6
    values = [3, 2, 4, 4]
    weights = [4, 3, 2, 3]

    expected = [0, 0, 1, 1]
    solution = solver(capacity, values, weights)
    check_solution(solution, expected, values, weights, capacity)
    return

check_examples(brute_knapsack)
#+end_src

Let's look at a particular solution.

#+begin_src python :results output :exports both
values = [3, 4, 2, 4]
weights = [4, 2, 3, 3]
capacity = 6
solution = brute_knapsack(capacity=capacity, values=values, weights=weights)
print(f"Call Count: {solution.count}")
print(f"Chosen knapsack value {solution.value}")
print(f"Item inventory: {solution.inventory}")

expect(solution.count).to(equal(len(values) * 2**len(values)))
expect(solution.value).to(equal(8))
expect(solution.inventory).to(contain_exactly(0, 1, 0, 1))
#+end_src

#+RESULTS:
: Call Count: 64
: Chosen knapsack value 8
: Item inventory: [0, 1, 0, 1]

So we have a solution that works, but the runtime is \(n2^n\) so let's make a version that does a little better.

** A Recursive Exhaustive Search
#+begin_src python :results none
def exhaustive_knapsack(capacity: int, values: list, weights: list,
                        count: int=0) -> Solution:
    """Finds the best selection of items to maximize value
    
    Args:
     capacity: maximum weight allowed
     values: value for each item available
     weights: how much each item weighs
     count: number of recursions

    Returns:
     best-value, count of each item, count of loops
    """
    assert len(values) == len(weights)
    count += 1

    if len(values) == 0:
        value = NEGATIVE_INFINITY if capacity < 0 else 0
        return Solution(value, [], count)

    value = 0

    values_and_weights = zip(values, weights)
    best = NEGATIVE_INFINITY
    best_solution = None
    
    for item, (value, weight) in enumerate(values_and_weights):
        remaining = capacity - weight
        next_item = item + 1
        descendant_output = exhaustive_knapsack(capacity=remaining,
                                                values=values[next_item:],
                                                weights=weights[next_item:],
                                                count=count)
        value += descendant_output.value
        count = descendant_output.count
        if value > best:
            best = value
            best_solution = [0] * item + [1] + descendant_output.inventory
    return Solution(value=best, inventory=best_solution, count=count)
#+end_src

** Checking The Exhaustive
#+begin_src python :results none
solution = exhaustive_knapsack(-5, [], [])
expect(solution.value).to(equal(NEGATIVE_INFINITY))

solution = exhaustive_knapsack(5, [], [])
expect(solution.value).to(equal(0))

check_examples(exhaustive_knapsack)
#+end_src

Let's look at that example that we looked at for the iterative brute-force version.

#+begin_src python :results output :exports both
values = [3, 4, 2, 4]
weights = [4, 2, 3, 3]
capacity = 6
solution = exhaustive_knapsack(capacity=capacity, values=values, weights=weights)
brute_solution = brute_knapsack(capacity=capacity, values=values, weights=weights)
print(f"Call Count: {solution.count}")
print(f"Chosen knapsack value {solution.value}")
print(f"Item inventory: {solution.inventory}")

expect(solution.count).to(equal(2**len(values)))
expect(solution.value).to(equal(brute_solution.value))
expect(solution.inventory).to(contain_exactly(*brute_solution.inventory))
#+end_src

#+RESULTS:
: Call Count: 16
: Chosen knapsack value 8
: Item inventory: [0, 1, 0, 1]

So now the number calls has gone down to \(2^n\), which is better, but not what we want just yet.
* Levitin's Memory Function
This is a memoized function that is in {{% lancelot "Levitin's book" %}}itdaa{{% /lancelot %}}. It looks slightly different from the other memoized functions in the other books (but they all look slightly different from each other anyway) but it's only cosmetic. I've been creating the final solution list of items to use in the functions themselves but I'm going to try doing it the way the books do and separate out the solution using a re-creation function afterwards.

** Some Pseudocode
**Note:** Levitin keeps the weights, values, and solution table in the global space so it doesn't appear in the pseudocode. I'm going to copy that here but change it when I get to implementing it.
I'm also going to change the variables a little to get them a little closer to the names I use. I'll call the eternal collections $Table$, $Weights$, and $Values$.

The $Table$ is an $items \times capacity$ table, with from 0 to number of items rows and 0 to the capacity columns. The 0 row and 0 column get initialized with 0 and the other cells with -1. If we have 4 items and a knapsack capacity of 5 we'd have an initial table like this.

|   | 0 |  1 |  2 |  3 |  4 |  5 |
|---+---+----+----+----+----+----|
| / | < |    |    |    |    |    |
| 0 | 0 |  0 |  0 |  0 |  0 |  0 |
| 1 | 0 | -1 | -1 | -1 | -1 | -1 |
| 2 | 0 | -1 | -1 | -1 | -1 | -1 |
| 3 | 0 | -1 | -1 | -1 | -1 | -1 |
| 4 | 0 | -1 | -1 | -1 | -1 | -1 |

Where the rows are the items and the columns are the used-capacities for the knapsack.

#+begin_export html
<pre id="memory-function-algorithm" style="display:hidden;">
\begin{algorithm}
\caption{Memory Function Knapsack Solver}
\begin{algorithmic}
\INPUT $i$: the number of the first items to consider.
\INPUT $c$: the knapsack's capacity.
\OUTPUT Value of the optimal subset of the first $i$ items that fit in the knapsack.
\PROCEDURE{MFKnapsack}{$i, c$}
\IF {\textit{Table}$[i, c] < 0$}
 \IF {$c < \textit{Weights}[i]$}
  \STATE $v \gets $ \textsc{MFKnapsack}($i - 1, c$)
 \ELSE
  \STATE $v \gets $ \textsc{Max}(\textsc{MFKnapsack}($i - 1, c$), $\textit{Values}[i] + $ \textsc{MFKnapsack}($i - 1, c - \textit{Weights}[i]$))
 \ENDIF
 \STATE $\textit{Table}[i, c] \gets v$
\ENDIF
\RETURN $\textit{Table}[i, c]$
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

To start the function you would pass in the total number of items as the argument for $i$. Since we initialized the cells (other than the zero row and column) with -1 the initial /if/ is a check to see if the item and capacity passed to the function is already in the table and if it isn't we run the body but if it is we can just return the value from the table.

In the body if the weight of the current item is beyond the remaining capacity of the knapsack we pick the value for the previous item using the current capacity. If the current item will fit in the knapsack then we pick the larger of the previous item's entry with the current capacity and the value of the current item plus the previous item's entry for the current capacity minus the weight of the current item - meaning we pick the bigger of the values we get if we skip this item or keep it.

1. If the item and capacity aren't in the table:
   - If the item's weight is greater than the remaining capacity use the previous item's value for the current capacity.
   - Otherwise use the greater of the previous item's value and this item's value plus the previous item's value for the current capacity minus the current item's weight (the capacity if you use the current item)
   - Whichever value you use, set it to the table's entry for this item and the current capacity
2. Return the table entry for this item and the current capacity

** Some Python
*** A Table Maker

#+begin_src python :results none
def make_table(capacity: int, items: int) -> list:
    """Make the memo-table

    Args:
     capacity: the starting capacity for the knapsack
     items: number of candidate items to put in the knapsack

    Returns:
     items + 1 x capacity + 1 list of lists: 0's in 0 column/row, -1 elsewhere
    """
    first_row = [0] * (capacity + 1)
    row = [0] + [-1] * capacity
    table = [row[:] for item in range(items)]
    table = [first_row] + table
    return table
#+end_src

*** Check the table maker
#+begin_src python :results none
capacity, items = 5, 4
table = make_table(capacity=capacity, items=items)

# one row per item plus a zero row
expect(len(table)).to(equal(items + 1))

# columns from 0...capacity
expect(len(table[0])).to(equal(capacity + 1))

# first row should be 0's
expect(sum(table[0])).to(equal(0))

# first column should be 0's
expect(sum(row[0] for row in table)).to(equal(0))

# everything else should be -1 (items x capacity sub-array)
expect(sum(sum(row) for row in table)).to(equal(-1 * (items * capacity)))
#+end_src

** Memory-Function Knapsack
#+begin_src python :results none
def memory_function_knapsack(item: int, capacity: int, values: list, weights: list,
                             table: list, count: int=0) -> int:
    """Find the best total value for the knapsack
    
    Args:
     item: the number of the item to use (0...item)
     capacity: maximum weight allowed
     values: value for each item available
     weights: how much each item weighs
     table: memo-table to store the sub-problem values
     count: number of calls

    Returns:
     best-value
    """
    count += 1
    # the table is 0-based but the values and weights 1-based 
    # so we need to adjust
    this_item = item - 1
    if table[item][capacity] < 0:
        previous_item = item - 1
        previous_value, count = memory_function_knapsack(previous_item, capacity, 
                                                    values, weights, table, count)
        if capacity < weights[this_item]:
            value = previous_value
        else:
            lookup_value, count = memory_function_knapsack(
                previous_item,
                capacity - weights[this_item],
                values, weights, table, count)
            this_value = lookup_value + values[this_item]
            value = max(previous_value, this_value)
        table[item][capacity] = value
    return table[item][capacity], count
#+end_src

#+begin_src python :results none
weights = [2, 1, 3, 2]
values = [12, 10, 20, 15]
items = len(weights)
capacity = 5
table = make_table(capacity, items)
value, count = memory_function_knapsack(items, capacity, values, weights, table)
expect(value).to(equal(37))

expected_table = [[0, 0, 0, 0, 0, 0],
                  [0, 0, 12, 12, 12, 12],
                  [0, -1, 12, 22, -1, 22],
                  [0, -1, -1, 22, -1, 32],
                  [0, -1, -1, -1, -1, 37]]
for row_index, row in enumerate(table):
    expect(row).to(contain_exactly(*expected_table[row_index]))
#+end_src

** Recovering the Solution
Although knowing what the optimal value is for the knapsack is somewhat informative in that it tells us what we can expect to achieve, it isn't really the solution since we don't know what items actually give us this value, so we're going to need to reconstruct it from the table.

#+begin_src python :results none
def knapsack_reconstruction(table: list, weights: list, values: list) -> list:
    """Reconstructs the optimal knapsack load using the table
    
    Args:
     table: items + 1 x capacity + 1 list of lists (array)
     weights: weights for each item
     values: values for each item

    Returns:
     inventory of items in the optimal knapsack
    """
    table = table[1:]
    items = len(table)
    assert items == len(weights)
    assert len(weights) == len(values)
    solution = [0] * items
    remaining_capacity = len(table[0]) - 1
    
    for item in reversed(range(items)):
        previous_item = item - 1
        if (weights[item] <= remaining_capacity and
            table[previous_item][remaining_capacity - weights[item]]
            + values[item] >= table[previous_item][remaining_capacity]):
            solution[item] = 1
            remaining_capacity -= weights[item]
    return solution
#+end_src

#+begin_src python :results none
weights = [2, 1, 3, 2]
values = [12, 10, 20, 15]
items = len(weights)
capacity = 5
table = make_table(capacity, items)
value, count = memory_function_knapsack(items, capacity,
                                 values, weights, table)

solution = knapsack_reconstruction(table, weights, values)
expect(solution).to(contain_exactly(1, 1, 0, 1))
#+end_src
** A Top-Function to Setup the MF Knapsack function

#+begin_src python :results none
def memoized_knapsack(capacity: int, values: list, weights: list) -> TableSolution:
    """Find the best total value for the knapsack
    
    Args:
     capacity: maximum weight allowed
     values: value for each item available
     weights: how much each item weighs

    Returns:
     best-value, count of each item, count of loops, solution table
    """
    assert len(values) == len(weights)
    items = len(values)
    table = make_table(capacity, items)
    value, count = memory_function_knapsack(items, capacity, values, weights, table)
    inventory = knapsack_reconstruction(table, weights, values)
    return TableSolution(value, inventory, count, table)
#+end_src

#+begin_src python :results output :exports both
solution = memoized_knapsack(capacity, values, weights)
print(f"Optimal Value: {solution.value}")
print(f"Call Count: {solution.count}")
check_examples(memoized_knapsack)
#+end_src

#+RESULTS:
: Optimal Value: 37
: Call Count: 22

Our solution is correct, but if you count all the function calls, not just the calls where the solution isn't in the table yet, it takes more calls than our exhaustive function. In fact, because we require that the recursions go to the extra zero columns or rows that we added, there's exactly double the number of calls where we add values to the table (if you move the count increment inside the first conditional it goes down to 11). So, even ignoring the table creation and solution lookup it seems that our solution takes more calls than the exhaustive search, unless we consider the zero-th item with zero weight and zero value that we add to the table as a required part of the problem, in which case our exhaustive solution would take \(2^5=32\), making the memoized version better. But this doesn't feel right.
* Dynamic Programming
* Levitin's Example
This is the (toy) example given by {{% lancelot "Levitin" %}}itdaa{{% /lancelot %}}. Our knapsack can hold a total weight of 10 and we have four items to choose from.

| Item | Weight | Value |
|------+--------+-------|
|    1 |      7 |    42 |
|    2 |      3 |    12 |
|    3 |      4 |    40 |
|    4 |      5 |    25 |

* Non-Greedy Toy Example
Say our knapsack still has a capacity of 10 and we again have four items.

| Item | Weight | Value |
|------+--------+-------|
|    1 |      7 |    42 |
|    2 |      4 |    20 |
|    3 |      5 |    25 |
|    4 |      6 |     6 |

If we use a greedy approach we'll end up with item 1 and a value of 42, while the optimal answer is to take items 2 and 3 for a value of 45.
* Sources
- {{% doc %}}clrs{{% /doc %}}
- {{% doc %}}algorithms-illuminated-part-3{{% /doc %}}
- {{% doc %}}itdaa{{% /doc %}}

#+begin_export html
<script>
window.addEventListener('load', function () {
    pseudocode.renderElement(document.getElementById("memory-function-algorithm"));
});
</script>
#+end_export
