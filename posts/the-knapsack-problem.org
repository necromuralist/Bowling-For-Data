#+BEGIN_COMMENT
.. title: The Knapsack Problem
.. slug: the-knapsack-problem
.. date: 2022-06-27 12:42:46 UTC-07:00
.. tags: algorithms,optimization
.. category: Optimization
.. link: 
.. description: A look at the Knapsack Problem
.. type: text
.. has_pseudocode: yes
#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-1f57c53d-4401-4217-ba41-9eb3a439ec28-ssh.json
#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
* The Knapsack Problems
The basic premise of the /Knapsack Problem/ is that we have a knapsack with a maximum capacity (/C/) and a selection of /n/ items, each item having a weight (\(w_i\)) and a value (\(v_i\)), and we want to pick the items that give us the most total value without exceeding the capacity of our knapsack.

There are two forms of the problem. The first form is what {{% lancelot "CLRS" %}}clrs{{% /lancelot %}} 
calls the \(\textit{0-1 Knapsack Problem}\) because we can either take the item ($1$) or not take the item ($0$) as opposed to the \(\textit{Fractional Knapsack Problem}\) where the "items" are things that we can take fractional portions of (if we're loading up on spices the \(\textit{0-1}\) problem might be pre-packaged spices while the \(\textit{fractional}\) problem involves scooping spices out of the bulk bins).

Although the problems look more or less the same, the fractional problem is one that can be solved using a greedy algorithm while the 0-1 problem can fail if you use a greedy approach so the all-or-nothing version is the more interesting case and the one we'll look at here.

* The Brute Force Solution
One way to find the optimal load for our knapsack is to find all the possible loads and taking the best load from those that will fit in the knapsack. This requires us to calculate the values for {{% lancelot "every subset" %}}number-of-subsets-in-a-set{{% /lancelot %}} of items which means we'll have to do \(2^n\) calculations.

* The Greedy Approach
* Dynamic Programming
* Levitin's Example
This is the (toy) example given by {{% lancelot "Levitin" %}}itdaa{{% /lancelot %}}. Our knapsack can hold a total weight of 10 and we have four items to choose from.

| Item | Weight | Value |
|------+--------+-------|
|    1 |      7 |    42 |
|    2 |      3 |    12 |
|    3 |      4 |    40 |
|    4 |      5 |    25 |

* Non-Greedy Toy Example
Say our knapsack still has a capacity of 10 and we again have four items.

| Item | Weight | Value |
|------+--------+-------|
|    1 |      7 |    42 |
|    2 |      4 |    20 |
|    3 |      5 |    25 |
|    4 |      6 |     6 |

If we use a greedy approach we'll end up with item 1 and a value of 42, while the optimal answer is to take items 2 and 3 for a value of 45.
* Sources
- {{% doc %}}clrs{{% /doc %}}
- {{% doc %}}algorithms-illuminated-part-3{{% /doc %}}
- {{% doc %}}itdaa{{% /doc %}}
