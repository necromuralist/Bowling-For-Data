#+BEGIN_COMMENT
.. title: The Knapsack Problem
.. slug: the-knapsack-problem
.. date: 2022-06-27 12:42:46 UTC-07:00
.. tags: algorithms,optimization
.. category: Optimization
.. link: 
.. description: A look at the Knapsack Problem
.. type: text
.. has_pseudocode: yes
#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-09f23e8c-9aa7-46f7-a2a1-73490b755ae4-ssh.json
#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
* The Knapsack Problem(s)
The basic premise of the /Knapsack Problem/ is that we have a knapsack with a maximum capacity (/C/) and a selection of /n/ items, each item having a weight (\(w_i\)) and a value (\(v_i\)), and we want to pick the items that give us the most total value without exceeding the capacity of our knapsack.

There are two forms of the problem. The first form is what {{% lancelot "CLRS" %}}clrs{{% /lancelot %}} 
calls the \(\textit{0-1 Knapsack Problem}\) because we can either take the item ($1$) or not take the item ($0$) as opposed to the \(\textit{Fractional Knapsack Problem}\) where the "items" are things that we can take fractional portions of (if we're loading up on spices the \(\textit{0-1}\) problem might be pre-packaged spices while the \(\textit{fractional}\) problem involves scooping spices out of the bulk bins).

Although the problems look more or less the same, the fractional problem is one that can be solved using a greedy algorithm while the 0-1 problem can fail if you use a greedy approach so the all-or-nothing version is the more interesting case and the one we'll look at here.

** Imports
#+begin_src python :results none
# python
from collections import namedtuple

import random

# pypi
from attrs import define
from expects import (be_below_or_equal, contain_exactly, equal, expect,
                     raise_error)
from joblib import Parallel, delayed

import altair
import pandas

# other monkey stuff
from graeae.visualization.altair_helpers import output_path, save_chart
from graeae import Timer
#+end_src

** Setup
#+begin_src python :results none
Solution = namedtuple("Solution", "value inventory count")
TableSolution = namedtuple("TableSolution", "value inventory count table")
NEGATIVE_INFINITY = float("-inf")
TIMER = Timer()
#+end_src
* The Brute Force Solution
One way to find the optimal load for our knapsack is to find all the possible loads and taking the best load from those that will fit in the knapsack. This requires us to calculate the values for {{% lancelot "every subset" %}}number-of-subsets-in-a-set{{% /lancelot %}} of items which means we'll have to do \(2^n\) calculations.

** An Iterative Brute-Force Version
To have a reference solution I'll make a brute-force iterative version of the knapsack solver. This will have a greater runtime (\(n 2^n\)) but sometimes starting with something easy is useful, even if it's not the solution we ultimately want.

#+begin_src python :results none
def brute_knapsack(capacity: int, values: list, weights: list) -> Solution:
    """Finds the best selection of items to maximize value
    
    Args:
     capacity: maximum weight allowed
     values: value for each item available
     weights: how much each item weighs

    Returns:
     best-value, count of each item, count of loops
    """
    assert len(values) == len(weights)

    number_of_items = len(values)
    items = [0] * number_of_items
    best_value = 0
    count = 0

    for combination in range(2**(number_of_items)):
        value, weight, carry = 0, 0, 1
        for item in range(number_of_items):
            increment = items[item] + carry
            keep = increment % 2
            carry = increment//2
            if keep:
                value += values[item]
                weight += weights[item]
            items[item] = keep
            count += 1
        if weight <= capacity and value > best_value:
            best_value = value
            solution = items[:]

    return Solution(value=best_value, inventory=solution, count=count)
#+end_src

** Checking the Brute
#+begin_src python :results none
def check_solution(solution: Solution,
                   expected_inventory: list,
                   values: list, weights: list, capacity: int):
    """Check that the solution matches the expected

    Args:
     solution: namedtuple with the knapsack solution
     expected_inventory: list of 0's and 1's representing which items to keep
     expected_value: total value expected for the solution
     values: values for the items
     weights: weights for the items
     capacity: maximum weight for the knapsack

    Raises:
     AssertionError if something isn't the expected
    """
    expect(solution.inventory).to(contain_exactly(*expected_inventory))
    value = sum([loot for index, loot in enumerate(values)
                 if solution.inventory[index]])
    weight = sum([poundage for index, poundage in enumerate(weights)
                  if solution.inventory[index]])

    expected_value = sum([loot for index, loot in enumerate(values)
                          if expected_inventory[index]])
    expect(value).to(equal(expected_value))
    expect(weight).to(be_below_or_equal(capacity))
    return
#+end_src

#+begin_src python :results none
def check_examples(solver: object) -> None:
    """Check the toy examples

    Args:
     solver: function to find the optimal knapsack load
    """
    # values and weights don't match
    # broken = lambda : solver(5, [0, 1], [2, 1, 3])
    # expect(broken).to(raise_error(AssertionError))

    capacity = 10
    values = [42, 12, 40, 25]
    weights = [7, 3, 4, 5]
    expected = [0, 0, 1, 1]

    solution = solver(capacity, values, weights)
    check_solution(solution, expected, values, weights, capacity)

    capacity = 6
    values = [3, 2, 4, 4]
    weights = [4, 3, 2, 3]

    expected = [0, 0, 1, 1]
    solution = solver(capacity, values, weights)
    check_solution(solution, expected, values, weights, capacity)
    return

check_examples(brute_knapsack)
#+end_src

Let's look at a particular solution.

#+begin_src python :results output :exports both
values = [3, 4, 2, 4]
weights = [4, 2, 3, 3]
capacity = 6
solution = brute_knapsack(capacity=capacity, values=values, weights=weights)
print(f"Call Count: {solution.count}")
print(f"Chosen knapsack value {solution.value}")
print(f"Item inventory: {solution.inventory}")

expect(solution.count).to(equal(len(values) * 2**len(values)))
expect(solution.value).to(equal(8))
expect(solution.inventory).to(contain_exactly(0, 1, 0, 1))
#+end_src

#+RESULTS:
: Call Count: 64
: Chosen knapsack value 8
: Item inventory: [0, 1, 0, 1]

So we have a solution that works, but the runtime is \(n2^n\) so let's make a version that does a little better.

** A Recursive Exhaustive Search
#+begin_src python :results none
def exhaustive_knapsack(capacity: int, values: list, weights: list,
                        count: int=0) -> Solution:
    """Finds the best selection of items to maximize value
    
    Args:
     capacity: maximum weight allowed
     values: value for each item available
     weights: how much each item weighs
     count: number of recursions

    Returns:
     best-value, count of each item, count of loops
    """
    assert len(values) == len(weights)
    count += 1

    if len(values) == 0:
        value = NEGATIVE_INFINITY if capacity < 0 else 0
        return Solution(value, [], count)

    value = 0

    values_and_weights = zip(values, weights)
    best = NEGATIVE_INFINITY
    best_solution = None
    
    for item, (value, weight) in enumerate(values_and_weights):
        remaining = capacity - weight
        next_item = item + 1
        descendant_output = exhaustive_knapsack(capacity=remaining,
                                                values=values[next_item:],
                                                weights=weights[next_item:],
                                                count=count)
        value += descendant_output.value
        count = descendant_output.count
        if value > best:
            best = value
            best_solution = [0] * item + [1] + descendant_output.inventory
    return Solution(value=best, inventory=best_solution, count=count)
#+end_src

** Checking The Exhaustive
#+begin_src python :results none
solution = exhaustive_knapsack(-5, [], [])
expect(solution.value).to(equal(NEGATIVE_INFINITY))

solution = exhaustive_knapsack(5, [], [])
expect(solution.value).to(equal(0))

check_examples(exhaustive_knapsack)
#+end_src

Let's look at that example that we looked at for the iterative brute-force version.

#+begin_src python :results output :exports both
values = [3, 4, 2, 4]
weights = [4, 2, 3, 3]
capacity = 6
solution = exhaustive_knapsack(capacity=capacity, values=values, weights=weights)
brute_solution = brute_knapsack(capacity=capacity, values=values, weights=weights)
print(f"Call Count: {solution.count}")
print(f"Chosen knapsack value {solution.value}")
print(f"Item inventory: {solution.inventory}")

expect(solution.count).to(equal(2**len(values)))
expect(solution.value).to(equal(brute_solution.value))
expect(solution.inventory).to(contain_exactly(*brute_solution.inventory))
#+end_src

#+RESULTS:
: Call Count: 16
: Chosen knapsack value 8
: Item inventory: [0, 1, 0, 1]

So now the number calls has gone down to \(2^n\), which is better, but not what we want just yet.
* Levitin's Memory Function
This is a memoized function that is in {{% lancelot "Levitin's book" %}}itdaa{{% /lancelot %}}. It looks slightly different from the other memoized functions in the other books (but they all look slightly different from each other anyway) but it's only cosmetic. I've been creating the final solution list of items to use in the functions themselves but I'm going to try doing it the way the books do and separate out the solution using a re-creation function afterwards.

** Some Pseudocode
**Note:** Levitin keeps the weights, values, and solution table in the global space so it doesn't appear in the pseudocode. I'm going to copy that here but change it when I get to implementing it.
I'm also going to change the variables a little to get them a little closer to the names I use. I'll call the eternal collections $Table$, $Weights$, and $Values$.

The $Table$ is an $items \times capacity$ table, with from 0 to number of items rows and 0 to the capacity columns. The 0 row and 0 column get initialized with 0 and the other cells with -1. If we have 4 items and a knapsack capacity of 5 we'd have an initial table like this.

|   | 0 |  1 |  2 |  3 |  4 |  5 |
|---+---+----+----+----+----+----|
| / | < |    |    |    |    |    |
| 0 | 0 |  0 |  0 |  0 |  0 |  0 |
| 1 | 0 | -1 | -1 | -1 | -1 | -1 |
| 2 | 0 | -1 | -1 | -1 | -1 | -1 |
| 3 | 0 | -1 | -1 | -1 | -1 | -1 |
| 4 | 0 | -1 | -1 | -1 | -1 | -1 |

Where the rows are the items and the columns are the used-capacities for the knapsack.

#+begin_export html
<pre id="memory-function-algorithm" style="display:hidden;">
\begin{algorithm}
\caption{Memory Function Knapsack Solver}
\begin{algorithmic}
\INPUT $i$: the number of the first items to consider.
\INPUT $c$: the knapsack's capacity.
\OUTPUT Value of the optimal subset of the first $i$ items that fit in the knapsack.
\PROCEDURE{MFKnapsack}{$i, c$}
\IF {\textit{Table}$[i, c] < 0$}
 \IF {$c < \textit{Weights}[i]$}
  \STATE $v \gets $ \textsc{MFKnapsack}($i - 1, c$)
 \ELSE
  \STATE $v \gets $ \textsc{Max}(\textsc{MFKnapsack}($i - 1, c$), $\textit{Values}[i] + $ \textsc{MFKnapsack}($i - 1, c - \textit{Weights}[i]$))
 \ENDIF
 \STATE $\textit{Table}[i, c] \gets v$
\ENDIF
\RETURN $\textit{Table}[i, c]$
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
#+end_export

To start the function you would pass in the total number of items as the argument for $i$. Since we initialized the cells (other than the zero row and column) with -1 the initial /if/ is a check to see if the item and capacity passed to the function is already in the table and if it isn't we run the body but if it is we can just return the value from the table.

In the body if the weight of the current item is beyond the remaining capacity of the knapsack we pick the value for the previous item using the current capacity. If the current item will fit in the knapsack then we pick the larger of the previous item's entry with the current capacity and the value of the current item plus the previous item's entry for the current capacity minus the weight of the current item - meaning we pick the bigger of the values we get if we skip this item or keep it.

1. If the item and capacity aren't in the table:
   - If the item's weight is greater than the remaining capacity use the previous item's value for the current capacity.
   - Otherwise use the greater of the previous item's value and this item's value plus the previous item's value for the current capacity minus the current item's weight (the capacity if you use the current item)
   - Whichever value you use, set it to the table's entry for this item and the current capacity
2. Return the table entry for this item and the current capacity


** Memory-Function Knapsack
The counts and such are cluttering up the function so I'm going to make this class-based.

#+begin_src python :results none
@define
class Memorizer:
    capacity: int
    values: list
    weights: list
    _table: list=None
    count: int=0
    _value: int=None
    _inventory: list=None

    @property
    def value(self) -> int:
        """The total value of the optimal knapsack"""
        if self._value is None:
            assert items == len(self.weights)
            assert len(weights) == len(self.values)
            self._value = self.find_value(len(self.weights),
                                          self.capacity)
        return self._value
            
    @property
    def table(self) -> list:
        """The memo table

        Returns:
        items + 1 x capacity + 1 list of lists: 0's in 0 column/row, -1 elsewhere
        """
        if self._table is None:
            first_row = [0] * (self.capacity + 1)
            row = [0] + [-1] * self.capacity
            table = [row[:] for item in range(len(self.values))]
            self._table = [first_row] + table
        return self._table

    def find_value(self, item: int, capacity: int) -> int:
        """Find the best total value for the knapsack
    
        Args:
         item: the number of the item to use (0...item)
         capacity: maximum weight allowed

        Returns:
         best-value
        """
        self.count += 1
        # the table is padded 
        # so we need to adjust the item index for weights, values
        this_item = item - 1
        if self.table[item][capacity] < 0:
            previous_item = item - 1
            previous_value = self.find_value(previous_item, capacity)
        
            if capacity < self.weights[this_item]:
                value = previous_value
            else:
                value = max(previous_value,
                            values[this_item] + self.find_value(
                                previous_item,
                                capacity - self.weights[this_item]))
            self.table[item][capacity] = value
        return self.table[item][capacity]

    @property
    def inventory(self) -> list:
        """Reconstructs the optimal knapsack load using the table
    
        Returns:
         inventory of items in the optimal knapsack
        """
        if self._inventory is None:
            # make sure that the problem has already been solved
            self()
            # get rid of the first row (the extra padding of zeros)
            table = self.table[1:]
            items = len(table)
            assert len(self.values) == items
            self._inventory = [0] * items
            remaining_capacity = len(table[0]) - 1
    
            for item in reversed(range(items)):
                previous_item = item - 1
                if (self.weights[item] <= remaining_capacity and
                    table[previous_item][remaining_capacity - self.weights[item]]
                    + self.values[item] >= table[previous_item][remaining_capacity]):
                    self._inventory[item] = 1
                    remaining_capacity -= self.weights[item]
        return self._inventory            

    def __call__(self) -> int:
        """Finds the best solution:
        
        As a side effect this also sets self.value

        Returns:
         value for optimal knapsack
        """
        return self.value
#+end_src

*** Check the table maker
#+begin_src python :results none
capacity, items = 5, 4
values = weights = [0] * items

table = Memorizer(capacity=capacity, weights=weights, values = values).table

# one row per item plus a zero row
expect(len(table)).to(equal(items + 1))

# columns from 0...capacity
expect(len(table[0])).to(equal(capacity + 1))

# first row should be 0's
expect(sum(table[0])).to(equal(0))

# first column should be 0's
expect(sum(row[0] for row in table)).to(equal(0))

# everything else should be -1 (items x capacity sub-array)
expect(sum(sum(row) for row in table)).to(equal(-1 * (items * capacity)))
#+end_src

*** Check the Final Table
#+begin_src python :results none
weights = [2, 1, 3, 2]
values = [12, 10, 20, 15]
capacity = 5
memoizer = Memorizer(weights=weights, values=values, capacity=capacity)
memoizer()
expect(memoizer.value).to(equal(37))

expected_table = [[0, 0, 0, 0, 0, 0],
                  [0, 0, 12, 12, 12, 12],
                  [0, -1, 12, 22, -1, 22],
                  [0, -1, -1, 22, -1, 32],
                  [0, -1, -1, -1, -1, 37]]

for row_index, row in enumerate(memoizer.table):
    expect(row).to(contain_exactly(*expected_table[row_index]))
#+end_src

*** Check the Recovered Solution
Although knowing what the optimal value is for the knapsack is somewhat informative in that it tells us what we can expect to achieve, it isn't really the solution since we don't know what items actually give us this value, so we're going to need to reconstruct it from the table.

#+begin_src python :results none
weights = [2, 1, 3, 2]
values = [12, 10, 20, 15]
capacity = 5

solution = Memorizer(capacity=capacity, values=values, weights=weights)

expect(solution.inventory).to(contain_exactly(1, 1, 0, 1))
#+end_src

*** Check It Against The Examples

#+begin_src python :results output :exports both
values = [3, 4, 2, 4]
weights = [4, 2, 3, 3]
capacity = 6

solution = Memorizer(capacity, values, weights)
print(f"Chosen knapsack value {solution.value}")
print(f"Item inventory: {solution.inventory}")
print(f"Call Count: {solution.count}")
check_examples(Memorizer)
#+end_src

#+RESULTS:
: Chosen knapsack value 8
: Item inventory: [0, 1, 0, 1]
: Call Count: 17

Our solution is correct, but if you count all the function calls, not just the calls where the solution isn't in the table yet, it takes more calls than our exhaustive function. 

** Compared to the Exhaustive Search
#+begin_src python :results none
sizes = list(range(4, 20))
values = [random.choices(list(range(size)), k=size) for size in sizes]
weights = [random.choices(list(range(random.randint(1, size) * size)), k=size)
           for size in sizes]
capacities = [sum(random.choices(weight, k=4)) for weight in weights]

capacities_values_weights = lambda: zip(capacities, values, weights)
#+end_src

#+begin_src python :results output :exports both
with TIMER:
    exhaustive_output = Parallel(n_jobs=-1)(
    delayed(exhaustive_knapsack)(*arguments)
        for arguments in capacities_values_weights())
#+end_src

#+RESULTS:
:RESULTS:
: Started: 2022-07-06 23:32:13.419817
: Ended: 2022-07-06 23:32:13.421391
: Elapsed: 0:00:00.001574
# [goto error]
#+begin_example
[0;31m---------------------------------------------------------------------------[0m
[0;31mTypeError[0m                                 Traceback (most recent call last)
[0;32m/tmp/ipykernel_60/1350999578.py[0m in [0;36m<module>[0;34m[0m
[1;32m      2[0m     exhaustive_output = Parallel(n_jobs=-1)(
[1;32m      3[0m     [0mdelayed[0m[0;34m([0m[0mexhaustive_knapsack[0m[0;34m)[0m[0;34m([0m[0;34m*[0m[0marguments[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0;32m----> 4[0;31m         for arguments in capacities_values_weights())
[0m
[0;32m/tmp/ipykernel_60/3338044842.py[0m in [0;36m<lambda>[0;34m()[0m
[1;32m      6[0m [0;34m[0m[0m
[1;32m      7[0m capacities_values_weights = lambda: zip(capacities, values, weights,
[0;32m----> 8[0;31m                                         strict=True)
[0m
[0;31mTypeError[0m: __new__() got an unexpected keyword argument 'strict'
#+end_example
:END:

* Dynamic Programming
* Levitin's Example
This is the (toy) example given by {{% lancelot "Levitin" %}}itdaa{{% /lancelot %}}. Our knapsack can hold a total weight of 10 and we have four items to choose from.

| Item | Weight | Value |
|------+--------+-------|
|    1 |      7 |    42 |
|    2 |      3 |    12 |
|    3 |      4 |    40 |
|    4 |      5 |    25 |

* Non-Greedy Toy Example
Say our knapsack still has a capacity of 10 and we again have four items.

| Item | Weight | Value |
|------+--------+-------|
|    1 |      7 |    42 |
|    2 |      4 |    20 |
|    3 |      5 |    25 |
|    4 |      6 |     6 |

If we use a greedy approach we'll end up with item 1 and a value of 42, while the optimal answer is to take items 2 and 3 for a value of 45.
* Sources
- {{% doc %}}clrs{{% /doc %}}
- {{% doc %}}algorithms-illuminated-part-3{{% /doc %}}
- {{% doc %}}itdaa{{% /doc %}}

#+begin_export html
<script>
window.addEventListener('load', function () {
    pseudocode.renderElement(document.getElementById("memory-function-algorithm"));
});
</script>
#+end_export
