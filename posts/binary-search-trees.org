#+BEGIN_COMMENT
.. title: Binary Search Trees
.. slug: binary-search-trees
.. date: 2022-03-08 16:37:49 UTC-08:00
.. tags: data structures,binary search trees,algorithms
.. category: Data Structures
.. link: 
.. description: Describing Binary Search Trees
.. type: text

#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-f28f7a37-3665-41f0-be78-be6d63804cdb-ssh.json
#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
#+begin_src python :tangle ../bowling/data_structures/binary_search_tree/node.py :exports none
<<imports>>

<<the-node>>

    <<equal>>

    <<less-than>>

    <<less-than-or-equal>>

    <<check-rep>>

    <<string-output>>
#+end_src

* What is a Binary Search Tree?
Stealing from {{% lancelot "CLRS" %}}clrs{{% /lancelot %}}.

- A Binary Search Tree is a linked structure of Nodes
- Each Node is an object
- Each node has a /Key/ (and /Data/) 
- Each Node has /Left/, /Right/, and /Parent/ attributes which point to the Left Child, Right-Child, and Parent of the Node.
- If a child is missing then it is set to /Nil/.
- The root Node is the only Node with a Parent set to /Nil/.

When describing Binary Search Trees I'll tend to refer to the Nodes but mean the Nodes' keys (e.g. to say a Node is less than another means its key is less than the other Node's).

* The Binary Search Tree Property
All the nodes in the left sub-tree of a node are less than or equal to the node and all the nodes in the right sub-tree of the node are greater than or equal to the node.
* The Node
** The Abstract
So the Binary Search Tree is a linked structure made up of Nodes that look more or less like this:

#+begin_src plantuml :file ../files/posts/binary-search-trees/node.png :exports none
!theme materia-outline

class Node {
 Key
 Node Left
 Node Right
 Node Parent
 Data
}
#+end_src

[[img-url:node.png]]

And in which the Binary Search Tree Property is maintained. I'm going to forego the data field and add a couple of methods to make it more convenient for me, but most of the way the tree is used will be by pass nodes (particularly the root) to functions.

** The Implementation
Since I'm using pypy 3.7 there's a problem with the declaration of an attribute of the Node class being a Node object (it isn't defined yet) but according to [[https://stackoverflow.com/questions/55320236/does-python-evaluate-type-hinting-of-a-forward-reference][this post on stackoverflow]] we can import ~annotations~ from the future to fix it.

#+begin_src python :noweb-ref imports
# python
from __future__ import annotations

# from pypi
# https://www.attrs.org/en/stable/index.html
from attrs import define

# this project
from bowling.types import Orderable
#+end_src

#+begin_src python :noweb-ref the-node
@define
class Node:
    """A Node in a Binary Search Tree

    Args:
     key: item to compare nodes
     parent: parent of this node
     left: left child
     right: right child
    """
    key: Orderable
    parent: Node=None
    left: Node=None
    right: Node=None
#+end_src
*** Comparisons
These are convenience methods to make it so that you can compare the node-objects without referring to the key (see the [[https://docs.python.org/3/reference/datamodel.html#object.__lt__][python Data Model documentation]]). In reading the documentation I thought that you had to implement everything, but after implementing /less than/ and /less than or equal to/ the /greater than/ and /greater than or equal to/ comparisons started to work. I guess if you don't implement them they just take the negative of the less than cases.

**** Equal
#+begin_src python :noweb-ref equal
def __eq__(self, other: Node) -> bool:
    """Check if the other node has an equal key"""
    return self.key == other.key
#+end_src

**** Less Than
#+begin_src python :noweb-ref less-than
def __lt__(self, other: Node) -> bool:
    """See if this key is less than the other's"""
    return self.key < other.key
#+end_src
**** Less Than or Equal
#+begin_src python :noweb-ref less-than-or-equal
def __le__(self, other: Node) -> bool:
    """See if this key is less than or other's"""
    return self.key <= other.key

#+end_src
*** Check Nodes
This is a convenience method to check if a node and its sub-trees maintain the Binary Search Tree Property. It calls the children too so that the whole tree can be checked by calling this on the root. Maybe it's overkill...

#+begin_src python :noweb-ref  check-rep
def check_node(self) -> None:
    """Checks that the Binary Search Tree Property holds

    Raises:
     AssertionError: Binary Search Tree Property was violated
    """
    assert self.parent is None or type(self.parent) is Node
    if self.left is not None:
        assert self.left <= self, f"Left: {self.left}, Self: {self}"
        self.left.check_node()

    if self.right is not None:
        assert self.right >= self, f"Right: {self.right}, Self: {self}"
        self.right.check_node()
    return
#+end_src
*** String Output
This is to make it a little easier to print.

#+begin_src python :noweb-ref string-output
def __str__(self) -> str:
    """The key as a string"""
    return str(self.key)
#+end_src
** Testing
I'll have to break this up later.

#+begin_src python :results none
# pypi
from expects import (
    be_above,
    be_above_or_equal,
    be_below,
    be_below_or_equal,
    be_none,
    equal,
    expect,
    raise_error
)

# software under test
from bowling.data_structures.binary_search_tree.node import Node

parent = Node(key=10)
parent.check_node()

expect(parent.key).to(equal(10))
expect(parent.left).to(be_none)
expect(parent.right).to(be_none)
expect(parent.parent).to(be_none)

uncle = Node(key=9)

expect(uncle).to(equal(Node(key=9)))
expect(uncle).to(be_below(parent))
expect(uncle).to(be_below_or_equal(parent))

brother = Node(key=20)
clone = Node(key=20)
expect(brother).to(be_above(parent))
expect(brother).to(be_above_or_equal(parent))

expect(brother).to(equal(clone))
expect(brother).to(be_above_or_equal(clone))
expect(brother).to(be_below_or_equal(clone))
expect(brother).not_to(be_below(clone))

# parent is root
expect(parent.check_node).not_to(raise_error)

# parent is right child
parent.parent = uncle
expect(parent.check_node).not_to(raise_error)

# parent is left child
parent.parent = brother
expect(parent.check_node).not_to(raise_error)

def bad_check():
    parent.check_node()
    return

lefty = Node(15)
parent.left = lefty
expect(bad_check).to(raise_error(AssertionError))

parent.left = None
parent.right = lefty
expect(parent.check_node).not_to(raise_error(AssertionError))

righty = Node(key=2)
parent.right = righty
expect(bad_check).to(raise_error(AssertionError))

parent.left = righty
parent.right = lefty
expect(parent.check_node).not_to(raise_error)

righty.left = Node(key=100)
expect(bad_check).to(raise_error(AssertionError))

righty.left.key = 0
expect(parent.check_node).not_to(raise_error)

lefty.right = Node(key=0)
expect(bad_check).to(raise_error(AssertionError))

expect(str(parent)).to(equal(str(parent.key)))
#+end_src


The {{% lancelot "next post" %}}binary-search-tree-in-order-traversal{{% /lancelot %}} will be about traversing the tree in the order of the nodes.

** Sources
- {{% doc %}}clrs{{% /doc %}}
